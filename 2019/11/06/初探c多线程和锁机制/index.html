<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="樱花雨"><title>初探C++多线程和锁机制 · 樱花雨</title><meta name="description" content="C++11开始支持多线程编程，并在之后的版本中不断完善。
Hello World单线程写法：12345#include &amp;lt;iostream&amp;gt;int main()&amp;#123;    std::cout &amp;lt;&amp;lt; &amp;quot;Hello World\n&amp;quot;;&amp;#125; 

"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">Home</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="/images/logo.webp"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:200px;" alt="favicon"><h3 title=""><a href="/">樱花雨</a></h3><div class="description"><p>爱你来自于蛮荒，一生不借谁的光</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/sakurafisch"><i class="fa fa-github"></i></a></li><li><a href="mailto:sakurafisch@gmail.com"><i class="fa fa-envelope"></i></a></li><li><a href="https://blog.winnerwinter.com/atom.xml"><i class="fa fa-rss"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> 樱花雨</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>初探C++多线程和锁机制</a></h3></div><div class="post-content"><p><p>C++11开始支持多线程编程，并在之后的版本中不断完善。</p>
<h4 id="Hello-World单线程写法："><a href="#Hello-World单线程写法：" class="headerlink" title="Hello World单线程写法："></a>Hello World单线程写法：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World\n&quot;</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="Hello-World多线程写法："><a href="#Hello-World多线程写法：" class="headerlink" title="Hello World多线程写法："></a>Hello World多线程写法：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span> <span class="comment">// 1</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span>      <span class="comment">// 2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello Concurrent World\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(hello)</span></span>; <span class="comment">// 3</span></span><br><span class="line">    t.<span class="built_in">join</span>();             <span class="comment">// 4</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="量产线程的写法："><a href="#量产线程的写法：" class="headerlink" title="量产线程的写法："></a>量产线程的写法：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_work</span><span class="params">(<span class="keyword">unsigned</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(do_work, i); <span class="comment">// 产生线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;entry : threads) <span class="comment">// 对每个线程调用 join()</span></span><br><span class="line">        entry.<span class="built_in">join</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="使用-std-lock-guard-保护共享数据："><a href="#使用-std-lock-guard-保护共享数据：" class="headerlink" title="使用 std::lock_guard 保护共享数据："></a>使用 <code>std::lock_guard</code> 保护共享数据：</h4><p>C++中通过实例化<code>std::mutex</code>创建互斥量实例，通过成员函数 <code>lock()</code> 对互斥量上锁，<code>unlock()</code> 进行解锁。不过，实践中不推荐直接去调用成员函数，调用成员函数就意味着，必须在每个函数出口都要去调用 <code>unlock()</code>，也包括异常的情况。C++标准库为互斥量提供了一个RAII语法的模板类<code>std::lock_guard</code>，在构造时就能提供已锁的互斥量，并在析构的时候进行解锁，从而保证了一个已锁互斥量能被正确解锁。</p>
<p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/thread/lock_guard">代码来源于 std::lock_guard</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_i = <span class="number">0</span>;</span><br><span class="line">std::mutex g_i_mutex; <span class="comment">// 保护 g_i</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">safe_increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_i_mutex)</span></span>;</span><br><span class="line">    ++g_i;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g_i_mutex 在锁离开作用域时自动释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(safe_increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(safe_increment)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用-std-shared-timed-mutex-避免数据竞争"><a href="#使用-std-shared-timed-mutex-避免数据竞争" class="headerlink" title="使用 std::shared_timed_mutex 避免数据竞争"></a>使用 <code>std::shared_timed_mutex</code> 避免数据竞争</h4><p><code>shared_timed_mutex</code> 类是能用于保护数据免受多个线程同时访问的同步原语。与其他促进排他性访问的互斥类型相反，拥有二个层次的访问：</p>
<ul>
<li>  <em>共享</em> - 多个线程能共享同一互斥的所有权。</li>
<li>  <em>排他性</em> - 仅一个线程能占有互斥。</li>
</ul>
<p>共享互斥通常用于多个读线程能同时访问同一资源而不导致数据竞争，但只有一个写线程能访问的情形。</p>
<p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/thread/shared_timed_mutex">代码来源于std::shared_timed_mutex</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">R</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">mutable</span> std::shared_timed_mutex mut;</span><br><span class="line">    <span class="comment">/* 数据 */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    R &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> R &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 要求排他性所有权以写入 *this</span></span><br><span class="line">        std::unique_lock&lt;std::shared_timed_mutex&gt; <span class="built_in">lhs</span>(mut, std::defer_lock);</span><br><span class="line">        <span class="comment">// 要求共享所有权以读取 other</span></span><br><span class="line">        <span class="function">std::shared_lock&lt;std::shared_timed_mutex&gt; <span class="title">rhs</span><span class="params">(other.mut, std::defer_lock)</span></span>;</span><br><span class="line">        std::<span class="built_in">lock</span>(lhs, rhs);</span><br><span class="line">        <span class="comment">/* 赋值数据 */</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    R r;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="使用-std-scoped-lock-避免死锁"><a href="#使用-std-scoped-lock-避免死锁" class="headerlink" title="使用 std::scoped_lock 避免死锁"></a>使用 <code>std::scoped_lock</code> 避免死锁</h4><p>线程有对锁的竞争：一对线程需要对他们所有的互斥量做一些操作，其中每个线程都有一个互斥量，且等待另一个解锁。这样没有线程能工作，因为他们都在等待对方释放互斥量。这种情况就是死锁，它的最大问题就是由两个或两个以上的互斥量来锁定一个操作。</p>
<p>C++标准库有办法解决这个问题，<code>std::scoped_lock</code>——可以一次性锁住多个(两个以上)的互斥量，并且没有副作用(死锁风险)，而且是RAII风格喵~。</p>
<p>以下示例用 <code>std::scoped_lock</code> 锁定互斥对而不死锁，且为 RAII 风格。</p>
<p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/thread/scoped_lock">代码来源于std::scoped_lock</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">Employee</span>(std::string id) : <span class="built_in">id</span>(id) &#123;&#125;</span><br><span class="line">    std::string id;</span><br><span class="line">    std::vector&lt;std::string&gt; lunch_partners;</span><br><span class="line">    std::mutex m;</span><br><span class="line">    <span class="function">std::string <span class="title">output</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::string ret = <span class="string">&quot;Employee &quot;</span> + id + <span class="string">&quot; has lunch partners: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;partner : lunch_partners)</span><br><span class="line">            ret += partner + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_mail</span><span class="params">(Employee &amp;, Employee &amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 模拟耗时的发信操作</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign_lunch_partner</span><span class="params">(Employee &amp;e1, Employee &amp;e2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> std::mutex io_mutex;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(io_mutex)</span></span>;</span><br><span class="line">        std::cout &lt;&lt; e1.id &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; e2.id &lt;&lt; <span class="string">&quot; are waiting for locks&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用 std::scoped_lock 取得二个锁，而无需担心</span></span><br><span class="line">        <span class="comment">// 其他对 assign_lunch_partner 的调用死锁我们</span></span><br><span class="line">        <span class="comment">// 而且它亦提供便利的 RAII 风格机制</span></span><br><span class="line"></span><br><span class="line">        <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(e1.m, e2.m)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等价代码 1 （用 std::lock 和 std::lock_guard ）</span></span><br><span class="line">        <span class="comment">// std::lock(e1.m, e2.m);</span></span><br><span class="line">        <span class="comment">// std::lock_guard&lt;std::mutex&gt; lk1(e1.m, std::adopt_lock);</span></span><br><span class="line">        <span class="comment">// std::lock_guard&lt;std::mutex&gt; lk2(e2.m, std::adopt_lock);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等价代码 2 （若需要 unique_lock ，例如对于条件变量）</span></span><br><span class="line">        <span class="comment">// std::unique_lock&lt;std::mutex&gt; lk1(e1.m, std::defer_lock);</span></span><br><span class="line">        <span class="comment">// std::unique_lock&lt;std::mutex&gt; lk2(e2.m, std::defer_lock);</span></span><br><span class="line">        <span class="comment">// std::lock(lk1, lk2);</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(io_mutex)</span></span>;</span><br><span class="line">            std::cout &lt;&lt; e1.id &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; e2.id &lt;&lt; <span class="string">&quot; got locks&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        e1.lunch_partners.<span class="built_in">push_back</span>(e2.id);</span><br><span class="line">        e2.lunch_partners.<span class="built_in">push_back</span>(e1.id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">send_mail</span>(e1, e2);</span><br><span class="line">    <span class="built_in">send_mail</span>(e2, e1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Employee <span class="title">alice</span><span class="params">(<span class="string">&quot;alice&quot;</span>)</span>, <span class="title">bob</span><span class="params">(<span class="string">&quot;bob&quot;</span>)</span>, <span class="title">christina</span><span class="params">(<span class="string">&quot;christina&quot;</span>)</span>, <span class="title">dave</span><span class="params">(<span class="string">&quot;dave&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在并行线程中指派，因为就午餐指派发邮件消耗很长时间</span></span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    threads.<span class="built_in">emplace_back</span>(assign_lunch_partner, std::<span class="built_in">ref</span>(alice), std::<span class="built_in">ref</span>(bob));</span><br><span class="line">    threads.<span class="built_in">emplace_back</span>(assign_lunch_partner, std::<span class="built_in">ref</span>(christina), std::<span class="built_in">ref</span>(bob));</span><br><span class="line">    threads.<span class="built_in">emplace_back</span>(assign_lunch_partner, std::<span class="built_in">ref</span>(christina), std::<span class="built_in">ref</span>(alice));</span><br><span class="line">    threads.<span class="built_in">emplace_back</span>(assign_lunch_partner, std::<span class="built_in">ref</span>(dave), std::<span class="built_in">ref</span>(bob));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;thread : threads)</span><br><span class="line">        thread.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; alice.<span class="built_in">output</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">              &lt;&lt; bob.<span class="built_in">output</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">              &lt;&lt; christina.<span class="built_in">output</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">              &lt;&lt; dave.<span class="built_in">output</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="使用更为灵活的std-unique-lock"><a href="#使用更为灵活的std-unique-lock" class="headerlink" title="使用更为灵活的std::unique_lock"></a>使用更为灵活的<code>std::unique_lock</code></h4><p><code>std::unqiue_lock</code> 使用更为自由的不变量，这样 <code>std::unique_lock</code> 实例不会总与互斥量的数据类型 相关，使用起来要比 <code>std:lock_guard</code> 更加灵活。首先，可将 <code>std::adopt_lock</code> 作为第二个参数传入 构造函数，对互斥量进行管理；也可以将 <code>std::defer_lock</code> 作为第二个参数传递进去，表明互斥量应 保持解锁状态。这样，就可以被 <code>std::unique_lock</code> 对象(不是互斥量)的 <code>lock()</code> 函数所获取，或传递 <code>std::unique_lock</code> 对象到 <code>std::lock()</code> 中。</p>
<p>当你想要锁定互斥锁时，可以创建类型为 <code>std::unique_lock</code>的局部变量，并将该互斥锁作为参数传递。 构造unique_lock时，它将锁定互斥锁，并且销毁该互斥锁后，它将解锁该互斥锁。 更重要的是：如果引发异常，则将调用 <code>std::unique_lock</code> 析构函数，因此互斥量将被解锁。</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/14709233/how-to-use-create-unique-lock-in-c">示例 1 代码来源于Stack Overflow</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> some_shared_var = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">    &#123;  <span class="comment">// Critical section</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(my_mutex)</span></span>;</span><br><span class="line">        some_shared_var += a;</span><br><span class="line">    &#125;  <span class="comment">// End of critical section</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/thread/unique_lock">示例 2 代码来源于std::unique_lock</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  示例 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Box</span><span class="params">(<span class="keyword">int</span> num)</span> : num_things&#123;</span>num&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num_things;</span><br><span class="line">    std::mutex m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Box &amp;from, Box &amp;to, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 仍未实际取锁</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(from.m, std::defer_lock)</span></span>;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(to.m, std::defer_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁两个 unique_lock 而不死锁</span></span><br><span class="line">    std::<span class="built_in">lock</span>(lock1, lock2);</span><br><span class="line"></span><br><span class="line">    from.num_things -= num;</span><br><span class="line">    to.num_things += num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#x27;from.m&#x27; 与 &#x27;to.m&#x27; 互斥解锁于 &#x27;unique_lock&#x27; 析构函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Box <span class="title">acc1</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">Box <span class="title">acc2</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(transfer, std::ref(acc1), std::ref(acc2), <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(transfer, std::ref(acc2), std::ref(acc1), <span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>我们现在会用C++写多线程代码啦，但是如何避免死锁，何种情况该用<code>std::lock_guard</code> 、<code>std::shared_timed_mutex</code>、<code>std::scoped_lock</code>、<code>std::unique_lock</code>，仍需要多加练习噢。</p>
</p><div class="tip">本文采用CC-BY-SA-3.0协议，转载请注明出处<br>Author: 樱花雨</div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-11-06</span><a class="tag" href="/categories/你发现了一条咸鱼/" title="你发现了一条咸鱼">你发现了一条咸鱼 </a><i class="fa fa-tag"></i><span class="leancloud_visitors"></span><span>About 1945 words, 6 min 29 sec  read</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://blog.winnerwinter.com/2019/11/06/初探c多线程和锁机制/,樱花雨,初探C++多线程和锁机制,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2019/11/17/%E5%B7%B1%E4%BA%A513-%E5%90%91%E6%81%B6%E5%8A%BF%E5%8A%9B%E4%BD%8E%E5%A4%B4/" title="己亥#13 | 向恶势力低头">Previous</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2019/11/06/c11-feature%E3%81%AE%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/" title="C++11 featureの右值引用">Next</a></li></ul></div><script src="/js/visitors.js"></script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>