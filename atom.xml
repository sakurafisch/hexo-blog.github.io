<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>樱花雨</title>
  
  
  <link href="https://blog.winnerwinter.com/atom.xml" rel="self"/>
  
  <link href="https://blog.winnerwinter.com/"/>
  <updated>2021-12-09T13:18:00.117Z</updated>
  <id>https://blog.winnerwinter.com/</id>
  
  <author>
    <name>sakurafisch</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>专业修电脑辅修开发</title>
    <link href="https://blog.winnerwinter.com/2021/11/18/%E4%B8%93%E4%B8%9A%E4%BF%AE%E7%94%B5%E8%84%91%E8%BE%85%E4%BF%AE%E5%BC%80%E5%8F%91/"/>
    <id>https://blog.winnerwinter.com/2021/11/18/%E4%B8%93%E4%B8%9A%E4%BF%AE%E7%94%B5%E8%84%91%E8%BE%85%E4%BF%AE%E5%BC%80%E5%8F%91/</id>
    <published>2021-11-18T15:45:22.000Z</published>
    <updated>2021-12-09T13:18:00.117Z</updated>
    
    <content type="html"><![CDATA[<p>今天早上上了数据库实验课，因为我已经在做后面的实验了，所以没什么体验感。<br>今天下午是密码学 Tutorial，学长讲题的思路大体上和我当时做的是一样的。但是他讲得有点简略呀，而且有些中间过程的正确性不敢恭维。<br>今天修了一整天实验室电脑，win 环境大概是配好了。逛了逛 Arch Linux 文档，发现现在用 archinstall 可以很无脑地安装系统，但是个人不建议选 Nvidia 驱动，因为可能会开不了机。另外貌似闲置的电脑还很多。要不要再占一台电脑装个 Arch Linux 呢（笑<br>QQ 群太多了，而且都是通知群，看消息很容易看漏。很烦这件事情。但目前还没有好的办法呢（摊手</p><p>我还遇到了一些其他问题，并制定如下对策：<br>作业和要去做的事情也容易记漏。对策：需要好好利用日历工具。<br>久坐在实验室腿部缺乏运动。晚上室友集体回宿舍，洗澡时间扎堆。对策：傍晚运动吃饭和洗澡，然后回实验室可以晚一点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天早上上了数据库实验课，因为我已经在做后面的实验了，所以没什么体验感。&lt;br&gt;今天下午是密码学 Tutorial，学长讲题的思路大体上和我当时做的是一样的。但是他讲得有点简略呀，而且有些中间过程的正确性不敢恭维。&lt;br&gt;今天修了一整天实验室电脑，win 环境大概是配好了。</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>去一下实验室吧</title>
    <link href="https://blog.winnerwinter.com/2021/11/17/%E5%8E%BB%E4%B8%80%E4%B8%8B%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%90%A7/"/>
    <id>https://blog.winnerwinter.com/2021/11/17/%E5%8E%BB%E4%B8%80%E4%B8%8B%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%90%A7/</id>
    <published>2021-11-17T15:29:32.000Z</published>
    <updated>2021-12-09T12:31:31.985Z</updated>
    
    <content type="html"><![CDATA[<p>自从昨天去了实验室看同学，才发现改造后的实验室已经比较舒适了。本科的时候因为宿舍氛围不利于工作，一直无法在宿舍开展工作，在宿舍开展工作是我的理想。现在的宿舍条件比之前好多了，作息规律而且安静，于是前段时间有点报复性地一直住在宿舍。之前为了打造宿舍的工作环境还特意买了一张桌子和一个台式机，但今天发现实验室配备的电脑配置已经好于我现有的两台电脑了。综合考虑，之后打算在实验室工作。</p><p>今天在实验室把编程的环境都配好了，可是还有点小问题需要 bios 密码才能解决。好吧明天去 8 楼找一下管电脑的学生干部。</p><p>今天的密码学内容我没能理解。回头再补吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自从昨天去了实验室看同学，才发现改造后的实验室已经比较舒适了。本科的时候因为宿舍氛围不利于工作，一直无法在宿舍开展工作，在宿舍开展工作是我的理想。现在的宿舍条件比之前好多了，作息规律而且安静，于是前段时间有点报复性地一直住在宿舍。之前为了打造宿舍的工作环境还特意买了一张桌子</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="https://blog.winnerwinter.com/2021/05/25/Hello-Hexo/"/>
    <id>https://blog.winnerwinter.com/2021/05/25/Hello-Hexo/</id>
    <published>2021-05-25T15:59:33.000Z</published>
    <updated>2021-12-09T12:31:31.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="换博客了"><a href="#换博客了" class="headerlink" title="换博客了"></a>换博客了</h1><p>今天把 Wordpress 换成 Hexo 了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;换博客了&quot;&gt;&lt;a href=&quot;#换博客了&quot; class=&quot;headerlink&quot; title=&quot;换博客了&quot;&gt;&lt;/a&gt;换博客了&lt;/h1&gt;&lt;p&gt;今天把 Wordpress 换成 Hexo 了！&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>庚子#8 | 端午将至</title>
    <link href="https://blog.winnerwinter.com/2020/06/19/%E5%BA%9A%E5%AD%908-%E7%AB%AF%E5%8D%88%E5%B0%86%E8%87%B3/"/>
    <id>https://blog.winnerwinter.com/2020/06/19/%E5%BA%9A%E5%AD%908-%E7%AB%AF%E5%8D%88%E5%B0%86%E8%87%B3/</id>
    <published>2020-06-19T08:17:55.000Z</published>
    <updated>2021-12-09T12:31:31.987Z</updated>
    
    <content type="html"><![CDATA[<p>仍记起去年，在课程压力比较大的大二下学期，端午节是和光年一起过的。时间过得真是快，转眼又到了今年的端午。</p><p>端午节总是在一年的中间，小时候过端午没有太多的感触，但随着年岁的增长，我越来越意识到端午正是总结上半年的生活的恰当时机。</p><p>今年上半年都宅家学习了，值得庆幸的是这学期的课比之前的学期真的少了很多。每次想起以前那么多课，我的心好痛。</p><p>上半年主要脉络我只记得个大概了：</p><p>5月前和家里人住在一起，天天宅在家里。我和 wuli 于2月29日成为研友，这件事情在我的预料之外，我感到非常幸运。</p><p>5月5日开始独居，继续宅在家里。</p><p>6月7日见了小宇。同一天，laoer 说她不打算考研了，打算出国。现在她在学德语。</p><p>6月10日和几个初中同学吃宵夜。</p><p>上半年其实过得挺普通的，不过我很喜欢这样平平淡淡的生活。</p><p>预计明天回去见家里人。待过了父亲节和端午节就继续独居。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;仍记起去年，在课程压力比较大的大二下学期，端午节是和光年一起过的。时间过得真是快，转眼又到了今年的端午。&lt;/p&gt;
&lt;p&gt;端午节总是在一年的中间，小时候过端午没有太多的感触，但随着年岁的增长，我越来越意识到端午正是总结上半年的生活的恰当时机。&lt;/p&gt;
&lt;p&gt;今年上半年都宅家学</summary>
      
    
    
    
    <category term="日常" scheme="https://blog.winnerwinter.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>庚子#7 | 旧友重逢</title>
    <link href="https://blog.winnerwinter.com/2020/06/07/%E5%BA%9A%E5%AD%907-%E6%97%A7%E5%8F%8B%E9%87%8D%E9%80%A2/"/>
    <id>https://blog.winnerwinter.com/2020/06/07/%E5%BA%9A%E5%AD%907-%E6%97%A7%E5%8F%8B%E9%87%8D%E9%80%A2/</id>
    <published>2020-06-07T14:16:07.000Z</published>
    <updated>2021-12-09T12:31:31.987Z</updated>
    
    <content type="html"><![CDATA[<p>独居了一个月，一个人的生活令人心情平静。唯独不好的是春夏交替的季节雨水甚多，电闪雷鸣时独自遥望窗外，雨淅淅沥沥打在绿植上，户外的人匆匆走着，直到后来再也看不到一个人，空留下空旷的道路旁的绿植和雨声，令人倍感孤独。</p><p>在昨天我很幸运地和老朋友相见。见到小宇时大概是早上9点，我们闲聊了一会，聊及高中和大学的细碎事情和共同认识的同学。</p><p>认识小宇，是在高一上学期的时候。当时去往同一所高中的初中同学不多，在一个新的学校里，我认识的人只有几个。当我发现小宇来自同一个镇的时候，我们很快有了共鸣。在高中的时候，我们经常三三两两去城市广场附近玩，过节留在学校的话偶尔会来往一下。高中毕业后，大一的时候因为我们都在小谷围岛，所以每学期都有相见，但后来小宇去了五山校区，我们就没有见过了。</p><p>早晨的空气清新开朗，我们逛了一下江滨公园。江滨公园是一个建在北江河畔的公园，站在江边的过道上，隔着栏杆低头是涛涛江水，隔江而望是对岸林立的高楼。我和小宇边走边聊，提及未来的去向，小宇确定要保研了，我仍不能预知未来何去何从。作为数学成绩不错的学生，小宇并不认为自己有数学天赋，而归因于自己做的数学练习题比较多。</p><p>在江滨公园逛完之后，我们移步到了赢之城，找了一个奶茶店落脚，我们似乎有聊不完的话题。之后随意逛了一下。事实证明我们两个都是没有逛街热情的人，在超市内走马观花看完了一系列商品最后没有要买的，在花店看绿植但是也不太感兴趣。</p><p>随意闲逛使我们偶遇了邓邓邓和他女朋友，邓邓邓说便便和她男朋友也在附近，打算下午唱歌，问我们要不要一起。唱歌当然好啊，虽然要so much money，但是还是可以玩得很开心的。然而后来由于便便的男朋友太害羞不想见太多陌生人，我们就没有加入到他们的唱歌队伍之中。</p><p>下午下雨，我和小宇用手机投屏到电视，看了一些节目。小宇看过很多动漫，总是和我聊这些，我仅有的动漫储备量有时会接不住这些话题。我们刚开始打算看《天气之子》，小宇说看过这部动漫觉得不错，我没看过的话（其实后来我想起来我看过），想和我再看一遍。后来因为投屏技术不够，我们改看了《<a href="https://www.bilibili.com/video/BV1hE411G73p">学习12小时+Dota 12小时</a>》《<a href="https://www.bilibili.com/video/BV1BJ411i7Sz">清华生的一天</a> 》。小宇说up主学过的课程他也学过，不过up主的课程作业和期末考试难度更大，所以看视频的时候比较有共鸣。不过他们学的课程我基本上没学过，什么《材料力学》《数理方程》，我只是听说过，所以在课程归属这一点上我没什么同感。</p><p>之后我们看了《<a href="https://www.bilibili.com/bangumi/media/md138412/?from=search&seid=16501729642436150009">动物世界</a>》，这是由腾讯影业出品的一部电影，名字起得不太好，不过看内容的话还不错。</p><p>晚饭，用我的三脚猫厨艺应付了一下小宇。这是一顿吃了很久的饭，可能是因为很久没见，我们聊了很多话题。小宇说了一些英国访学时的事情，以及之后计划去日本访学。并提到国内单程飞往日本需要4000元，而先坐车去香港，从香港飞往日本再飞回来也只是2000元。</p><p>大概晚上8点半，小宇准备回家，奈何在公交车站一直等车到10点15分都没有车，于是就计划明天早上再回去。</p><p>我们晚上又看了《勇敢者游戏2》这部电影，顺便给小宇科普了一些计算机网络的知识，然后就睡觉了。</p><p>第二天早上小宇回家。我们本质上都是很普通的人，希望每天开开心心。那么，期待我们的下一次相见。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;独居了一个月，一个人的生活令人心情平静。唯独不好的是春夏交替的季节雨水甚多，电闪雷鸣时独自遥望窗外，雨淅淅沥沥打在绿植上，户外的人匆匆走着，直到后来再也看不到一个人，空留下空旷的道路旁的绿植和雨声，令人倍感孤独。&lt;/p&gt;
&lt;p&gt;在昨天我很幸运地和老朋友相见。见到小宇时大概是</summary>
      
    
    
    
    <category term="日常" scheme="https://blog.winnerwinter.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>庚子#6 | Living Alone</title>
    <link href="https://blog.winnerwinter.com/2020/05/05/%E5%BA%9A%E5%AD%906-living-alone/"/>
    <id>https://blog.winnerwinter.com/2020/05/05/%E5%BA%9A%E5%AD%906-living-alone/</id>
    <published>2020-05-05T09:28:49.000Z</published>
    <updated>2021-12-09T12:31:31.986Z</updated>
    
    <content type="html"><![CDATA[<p>2020年的夏季，一如既往的热。与过往不同的是，今年的这个时候中国南部的大学生仍未回校。</p><p>今天开始独居，如无意外，将会独居到开学。</p><p>开学时间现在还未确定。如果这学期不用上学，那就独居到下学期开学。</p><p>有人说：一个安静的环境有利于高效工作。我赞成这种说法。</p><p>其实早些时候，我就计划独居了。碍于新冠疫情扩散，我的独居计划一直没有得以落实。</p><p>记得在上学期末的时候，大家考完试熙熙攘攘地回家了。当时我在筹划把主要工作地点从学校转移到家里，因此我带了几乎所有的衣服、几乎所有有用的书回家。</p><p>随着新冠疫情在国内得到进一步的控制，是时候开始独居了。形只影单，一丝孤独，一缕闲愁。</p><p>这时候不禁想起了高中数学老师写在泛黄的明信片上的话：耐得住寂寞，才守得住繁华。</p><p>—————— 我是美丽的分割线 ——————</p><p>刚吃完晚饭，来做一些补充。</p><p>清点了物资：现储备有9只鸡蛋，两块姜，两根青瓜，两罐龟零膏，一袋叉烧包，三个面饼，一小袋米。</p><p>今晚吃了鸡中翼炒青瓜</p><p>虽然吃起来很好吃，但是看起来很一般。看来要多逛逛小破站学习厨艺。（做菜已经很耗时间了，好不好看就算了吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2020年的夏季，一如既往的热。与过往不同的是，今年的这个时候中国南部的大学生仍未回校。&lt;/p&gt;
&lt;p&gt;今天开始独居，如无意外，将会独居到开学。&lt;/p&gt;
&lt;p&gt;开学时间现在还未确定。如果这学期不用上学，那就独居到下学期开学。&lt;/p&gt;
&lt;p&gt;有人说：一个安静的环境有利于高效工</summary>
      
    
    
    
    <category term="日常" scheme="https://blog.winnerwinter.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>友情至上</title>
    <link href="https://blog.winnerwinter.com/2020/04/10/%E5%8F%8B%E6%83%85%E8%87%B3%E4%B8%8A/"/>
    <id>https://blog.winnerwinter.com/2020/04/10/%E5%8F%8B%E6%83%85%E8%87%B3%E4%B8%8A/</id>
    <published>2020-04-10T00:36:28.000Z</published>
    <updated>2021-12-09T13:18:35.590Z</updated>
    
    <content type="html"><![CDATA[<p>能记下来的心情就记下吧，不然以后会忘掉的。</p><p>记得大一的时候，企鹅还在岛上。有一次我们在南亭吃烤鱼，我表示这样子和朋友吃烤鱼很有气氛，热腾腾的水雾往上冒，即使在寒冷的冬天，也使人感到温暖。</p><p>席间，我们聊到我们对友情的态度。至今我仍清晰地记得，这次吃饭，是我对关于朋友的价值观发生重大改变的转折点。</p><p>从小我就是一个理性的人，并确立过某些价值观。当时认为读书时候的朋友是临时的，过了一个阶段认识新的人，就会和以前的同学少联系了。事实证明，至今和我仍有联系的老同学为数不多。我觉得这有两方面因素，一是现在不联系的同学本来以前交往就不深，二是我没有刻意去挽留（对方也是。</p><p>学计算机网络的时候了解到分层设计的思想，下层向上层服务，下层屏蔽细节。私以为，人也应该这样吧，把自己艰辛的一面放在下层，向上提供屏蔽细节的服务。</p><p>以上内容编辑于2019年11月29日，当时不知什么原因没有继续写下去。今天是2020年4月10日，翻开这篇草稿，发现以前写下的内容已经不完全符合现在的价值观了。但是我不打算删改它，至少它代表了我某个时期的心情。</p><p>我猜当时的我要表达的是经历了岁月的洗礼仍能存留到现在的友情很重要，且行且珍惜。</p><p>随着认识的人越来越多，会发现大家的价值观很不一样，牛人的牛法不尽相同，因此不应在人际交往中苛刻求同。只要是积极向上的价值观就都是好的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;能记下来的心情就记下吧，不然以后会忘掉的。&lt;/p&gt;
&lt;p&gt;记得大一的时候，企鹅还在岛上。有一次我们在南亭吃烤鱼，我表示这样子和朋友吃烤鱼很有气氛，热腾腾的水雾往上冒，即使在寒冷的冬天，也使人感到温暖。&lt;/p&gt;
&lt;p&gt;席间，我们聊到我们对友情的态度。至今我仍清晰地记得，这次吃</summary>
      
    
    
    
    <category term="杂萃" scheme="https://blog.winnerwinter.com/categories/%E6%9D%82%E8%90%83/"/>
    
    
  </entry>
  
  <entry>
    <title>庚子#5 | 课务繁忙</title>
    <link href="https://blog.winnerwinter.com/2020/03/20/%E5%BA%9A%E5%AD%905-%E8%AF%BE%E5%8A%A1%E7%B9%81%E5%BF%99/"/>
    <id>https://blog.winnerwinter.com/2020/03/20/%E5%BA%9A%E5%AD%905-%E8%AF%BE%E5%8A%A1%E7%B9%81%E5%BF%99/</id>
    <published>2020-03-20T00:45:37.000Z</published>
    <updated>2021-12-09T12:31:31.986Z</updated>
    
    <content type="html"><![CDATA[<p><strong>组网</strong></p><p>组网也布置上机作业了，要好好听课了。</p><p><strong>Linux</strong></p><p>在上个星期上完Linux课不久后，我着手开始实验，并把实验报告写完了。可是本周上课的时候，张老师对作业提出了更高的要求。补充作业将是耗时耗力的事情。</p><p><strong>法语退课</strong></p><p>昨天晚上上了法语课的前半节，冯老师讲课条理清晰。但是随着知识难度的增加，我预料到法语课的知识需要在课后花一定的时间消化。于是在课间休息的时候，我通过企业联系冯老师，恳请退课事宜。</p><p>老师对此表示理解。于是我去教务系统把课退了。</p><p><strong>小结</strong></p><p>现在是2020年3月20日。自由的时间总是越多越好。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;组网&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;组网也布置上机作业了，要好好听课了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Linux&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在上个星期上完Linux课不久后，我着手开始实验，并把实验报告写完了。可是本周上课的时候，张老师对作业提出了</summary>
      
    
    
    
    <category term="日常" scheme="https://blog.winnerwinter.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>庚子#4 | 迎来课多的第一天</title>
    <link href="https://blog.winnerwinter.com/2020/03/12/%E5%BA%9A%E5%AD%904-%E8%BF%8E%E6%9D%A5%E8%AF%BE%E5%A4%9A%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <id>https://blog.winnerwinter.com/2020/03/12/%E5%BA%9A%E5%AD%904-%E8%BF%8E%E6%9D%A5%E8%AF%BE%E5%A4%9A%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9/</id>
    <published>2020-03-12T15:52:12.000Z</published>
    <updated>2021-12-09T12:31:31.986Z</updated>
    
    <content type="html"><![CDATA[<p>闹钟打破清静的早晨，慵懒的少年从被窝中坐起，缓缓下床，开始了他繁忙的一天。</p><p>今天的第一件事情莫过于抢阿里云半年免费的云服务器。用云服务器做完作业就扔是一个再好不过的选择。然鹅我因操作的时候犹豫了一下选哪个Linux发行版而错失良机。明日手速快起来，Arch Linux预定！</p><p>今天总共上了组网、Linux、Linux实验和法语课。上完Linux实验的时候不想继续上课差点把法语课给退了。不过考虑到还有七天的退课时间，还是先上上课再考虑。不过本次法语课体验不错，所以我得上完下周的课再考虑退不退，大概率不退吧。</p><p>法语比俄语明显简单好多，跟日语相比的话我比较不出来。</p><p>前天做完了2017英语一的卷子还没来得及整理相关笔记，今天又获得了新的课程作业。布置作业是不对的，委屈。</p><p>今天的吃饭时间受到了课程影响，不过久违地吃到了排骨和瘦肉，粗略算了一下价格感觉亏大了，近期不宜猪肉宜鸡鸭。</p><p>每周只有星期四课多其实还好啦。明天写作业，刻海星~</p><p>《Tu me manques》Sheryfa Luna</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;闹钟打破清静的早晨，慵懒的少年从被窝中坐起，缓缓下床，开始了他繁忙的一天。&lt;/p&gt;
&lt;p&gt;今天的第一件事情莫过于抢阿里云半年免费的云服务器。用云服务器做完作业就扔是一个再好不过的选择。然鹅我因操作的时候犹豫了一下选哪个Linux发行版而错失良机。明日手速快起来，Arch L</summary>
      
    
    
    
    <category term="日常" scheme="https://blog.winnerwinter.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>庚子#3 | 寒假终了</title>
    <link href="https://blog.winnerwinter.com/2020/03/09/%E5%BA%9A%E5%AD%903-%E5%AF%92%E5%81%87%E7%BB%88%E4%BA%86/"/>
    <id>https://blog.winnerwinter.com/2020/03/09/%E5%BA%9A%E5%AD%903-%E5%AF%92%E5%81%87%E7%BB%88%E4%BA%86/</id>
    <published>2020-03-09T13:24:56.000Z</published>
    <updated>2021-12-09T12:31:31.986Z</updated>
    
    <content type="html"><![CDATA[<p>按常理来说，今天是开学的第一天，但我星期三才有课。所以今天姑且也算是我的寒假。</p><p>这个寒假原本打算会独居很久的。为了应对新冠疫情，我在除夕前夕和家人团聚，并且至今也没有独居。 过年期间打了几天麻将。</p><p>翡翠台的《黄金有罪》《大酱园》《独孤皇后》成为了茶余饭后的消遣。其中《独孤皇后》 现在还没大结局 。在初一的时候看了《重啟咲良田》，《超炮T》一直有跟进，白井黑子牛逼！很喜欢up主机智的党妹的说话风格。</p><p>疫情期间虽然有新电影免费放在了网上，但是我没有去看，倒是花钱重温了《速度与激情8》。一直很喜欢速度与激情这个系列的电影，并非纯粹因为其中的街头情节和人物放荡不羁的个性，更因为他们无论遭遇何种困难始终把家庭放在很很重要的位置。</p><p>把学习强国刷到了4700分，最近开始着手经典诵读。</p><p>因为个人原因，我退出了一个十多人的里面全是放假就会聚到一起玩的初中同学的微信群。因为我希望今年的社交活动少一点。为了降低自己发说说和发朋友圈的欲望，把QQ空间设成了私密，把朋友圈设成了三天可见。里面没什么隐私，仅仅为了降低自己发说说和发朋友圈的欲望而已。</p><p>kx的社恐比我想象中的严重。</p><p>和wuli成了研友，互相打卡日常工作。</p><p>最近每天下午四点都会条件反射地觅食,主要是鸡蛋炒饭，衣带渐紧终不悔。</p><p>不爱听音乐的程序员不是好吃货。</p><p>《苏丽珂》The Red Army Choir</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;按常理来说，今天是开学的第一天，但我星期三才有课。所以今天姑且也算是我的寒假。&lt;/p&gt;
&lt;p&gt;这个寒假原本打算会独居很久的。为了应对新冠疫情，我在除夕前夕和家人团聚，并且至今也没有独居。 过年期间打了几天麻将。&lt;/p&gt;
&lt;p&gt;翡翠台的《黄金有罪》《大酱园》《独孤皇后》成为了</summary>
      
    
    
    
    <category term="日常" scheme="https://blog.winnerwinter.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>己亥#13 | 向恶势力低头</title>
    <link href="https://blog.winnerwinter.com/2019/11/17/%E5%B7%B1%E4%BA%A513-%E5%90%91%E6%81%B6%E5%8A%BF%E5%8A%9B%E4%BD%8E%E5%A4%B4/"/>
    <id>https://blog.winnerwinter.com/2019/11/17/%E5%B7%B1%E4%BA%A513-%E5%90%91%E6%81%B6%E5%8A%BF%E5%8A%9B%E4%BD%8E%E5%A4%B4/</id>
    <published>2019-11-16T17:42:53.000Z</published>
    <updated>2021-12-09T13:10:48.462Z</updated>
    
    <content type="html"><![CDATA[<p>开学的时候本以为自己有充足的时间考一下证，于是当时一冲动就报了BEC-H。记得国庆回家的时候，我带了BEC-H的书和数据结构的书回家，本来打算在家主要看BEC的，但结果BEC实在太难了，在家一直看数据结构。</p><p>这个学期要修的学分还是比较多，能自由安排的时间有限。之前曾探索过光年的时间安排方式，即以日历安排行程，不过现在已经弃坑了。本人还是比较喜欢随性的生活。</p><p>2019.11.16，这一天早上我去中大东校区考了BEC-H的阅读、写作、听力。阅读做了前面两大题就想离场放弃了。不过看到旁边的人都在认真做，我才坚持了下来。就感觉写作好写一点。听力听着听着手就微微颤抖。向恶势力低头。</p><p>早上考完听读写的我已经是没有灵魂的我了。回我校睡了一觉。按照准考证的时间，晚上18：45~19：00是口语考试时间。我在睡觉期间辗转反侧悲愤难眠，最终决定放弃口语部分的考试。</p><p>晚上没有去考试，取而代之的是，我去了GOGO和kx喝奶茶聊天。主要是聊天。从中我了解到广外的外语氛围真的比我校好很多。她舍友今天也考BEC，这位在我看来很神奇的她的舍友此前已经考过托福/雅思了的。</p><p>广外真是一个神奇的地方。在这个地方，外语大佬真多。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;开学的时候本以为自己有充足的时间考一下证，于是当时一冲动就报了BEC-H。记得国庆回家的时候，我带了BEC-H的书和数据结构的书回家，本来打算在家主要看BEC的，但结果BEC实在太难了，在家一直看数据结构。&lt;/p&gt;
&lt;p&gt;这个学期要修的学分还是比较多，能自由安排的时间有限。</summary>
      
    
    
    
    <category term="日常" scheme="https://blog.winnerwinter.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>初探C++多线程和锁机制</title>
    <link href="https://blog.winnerwinter.com/2019/11/06/%E5%88%9D%E6%8E%A2c%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>https://blog.winnerwinter.com/2019/11/06/%E5%88%9D%E6%8E%A2c%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%94%81%E6%9C%BA%E5%88%B6/</id>
    <published>2019-11-06T11:52:45.000Z</published>
    <updated>2021-12-09T13:22:03.997Z</updated>
    
    <content type="html"><![CDATA[<p>C++11开始支持多线程编程，并在之后的版本中不断完善。</p><h4 id="Hello-World单线程写法："><a href="#Hello-World单线程写法：" class="headerlink" title="Hello World单线程写法："></a>Hello World单线程写法：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World\n&quot;</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="Hello-World多线程写法："><a href="#Hello-World多线程写法：" class="headerlink" title="Hello World多线程写法："></a>Hello World多线程写法：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span> <span class="comment">// 1</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span>      <span class="comment">// 2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello Concurrent World\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(hello)</span></span>; <span class="comment">// 3</span></span><br><span class="line">    t.<span class="built_in">join</span>();             <span class="comment">// 4</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="量产线程的写法："><a href="#量产线程的写法：" class="headerlink" title="量产线程的写法："></a>量产线程的写法：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_work</span><span class="params">(<span class="keyword">unsigned</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(do_work, i); <span class="comment">// 产生线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;entry : threads) <span class="comment">// 对每个线程调用 join()</span></span><br><span class="line">        entry.<span class="built_in">join</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="使用-std-lock-guard-保护共享数据："><a href="#使用-std-lock-guard-保护共享数据：" class="headerlink" title="使用 std::lock_guard 保护共享数据："></a>使用 <code>std::lock_guard</code> 保护共享数据：</h4><p>C++中通过实例化<code>std::mutex</code>创建互斥量实例，通过成员函数 <code>lock()</code> 对互斥量上锁，<code>unlock()</code> 进行解锁。不过，实践中不推荐直接去调用成员函数，调用成员函数就意味着，必须在每个函数出口都要去调用 <code>unlock()</code>，也包括异常的情况。C++标准库为互斥量提供了一个RAII语法的模板类<code>std::lock_guard</code>，在构造时就能提供已锁的互斥量，并在析构的时候进行解锁，从而保证了一个已锁互斥量能被正确解锁。</p><p><a href="https://zh.cppreference.com/w/cpp/thread/lock_guard">代码来源于 std::lock_guard</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_i = <span class="number">0</span>;</span><br><span class="line">std::mutex g_i_mutex; <span class="comment">// 保护 g_i</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">safe_increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_i_mutex)</span></span>;</span><br><span class="line">    ++g_i;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g_i_mutex 在锁离开作用域时自动释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(safe_increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(safe_increment)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="使用-std-shared-timed-mutex-避免数据竞争"><a href="#使用-std-shared-timed-mutex-避免数据竞争" class="headerlink" title="使用 std::shared_timed_mutex 避免数据竞争"></a>使用 <code>std::shared_timed_mutex</code> 避免数据竞争</h4><p><code>shared_timed_mutex</code> 类是能用于保护数据免受多个线程同时访问的同步原语。与其他促进排他性访问的互斥类型相反，拥有二个层次的访问：</p><ul><li>  <em>共享</em> - 多个线程能共享同一互斥的所有权。</li><li>  <em>排他性</em> - 仅一个线程能占有互斥。</li></ul><p>共享互斥通常用于多个读线程能同时访问同一资源而不导致数据竞争，但只有一个写线程能访问的情形。</p><p><a href="https://zh.cppreference.com/w/cpp/thread/shared_timed_mutex">代码来源于std::shared_timed_mutex</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">R</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">mutable</span> std::shared_timed_mutex mut;</span><br><span class="line">    <span class="comment">/* 数据 */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    R &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> R &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 要求排他性所有权以写入 *this</span></span><br><span class="line">        std::unique_lock&lt;std::shared_timed_mutex&gt; <span class="built_in">lhs</span>(mut, std::defer_lock);</span><br><span class="line">        <span class="comment">// 要求共享所有权以读取 other</span></span><br><span class="line">        <span class="function">std::shared_lock&lt;std::shared_timed_mutex&gt; <span class="title">rhs</span><span class="params">(other.mut, std::defer_lock)</span></span>;</span><br><span class="line">        std::<span class="built_in">lock</span>(lhs, rhs);</span><br><span class="line">        <span class="comment">/* 赋值数据 */</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    R r;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="使用-std-scoped-lock-避免死锁"><a href="#使用-std-scoped-lock-避免死锁" class="headerlink" title="使用 std::scoped_lock 避免死锁"></a>使用 <code>std::scoped_lock</code> 避免死锁</h4><p>线程有对锁的竞争：一对线程需要对他们所有的互斥量做一些操作，其中每个线程都有一个互斥量，且等待另一个解锁。这样没有线程能工作，因为他们都在等待对方释放互斥量。这种情况就是死锁，它的最大问题就是由两个或两个以上的互斥量来锁定一个操作。</p><p>C++标准库有办法解决这个问题，<code>std::scoped_lock</code>——可以一次性锁住多个(两个以上)的互斥量，并且没有副作用(死锁风险)，而且是RAII风格喵~。</p><p>以下示例用 <code>std::scoped_lock</code> 锁定互斥对而不死锁，且为 RAII 风格。</p><p><a href="https://zh.cppreference.com/w/cpp/thread/scoped_lock">代码来源于std::scoped_lock</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">Employee</span>(std::string id) : <span class="built_in">id</span>(id) &#123;&#125;</span><br><span class="line">    std::string id;</span><br><span class="line">    std::vector&lt;std::string&gt; lunch_partners;</span><br><span class="line">    std::mutex m;</span><br><span class="line">    <span class="function">std::string <span class="title">output</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::string ret = <span class="string">&quot;Employee &quot;</span> + id + <span class="string">&quot; has lunch partners: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;partner : lunch_partners)</span><br><span class="line">            ret += partner + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_mail</span><span class="params">(Employee &amp;, Employee &amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 模拟耗时的发信操作</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign_lunch_partner</span><span class="params">(Employee &amp;e1, Employee &amp;e2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> std::mutex io_mutex;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(io_mutex)</span></span>;</span><br><span class="line">        std::cout &lt;&lt; e1.id &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; e2.id &lt;&lt; <span class="string">&quot; are waiting for locks&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用 std::scoped_lock 取得二个锁，而无需担心</span></span><br><span class="line">        <span class="comment">// 其他对 assign_lunch_partner 的调用死锁我们</span></span><br><span class="line">        <span class="comment">// 而且它亦提供便利的 RAII 风格机制</span></span><br><span class="line"></span><br><span class="line">        <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(e1.m, e2.m)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等价代码 1 （用 std::lock 和 std::lock_guard ）</span></span><br><span class="line">        <span class="comment">// std::lock(e1.m, e2.m);</span></span><br><span class="line">        <span class="comment">// std::lock_guard&lt;std::mutex&gt; lk1(e1.m, std::adopt_lock);</span></span><br><span class="line">        <span class="comment">// std::lock_guard&lt;std::mutex&gt; lk2(e2.m, std::adopt_lock);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等价代码 2 （若需要 unique_lock ，例如对于条件变量）</span></span><br><span class="line">        <span class="comment">// std::unique_lock&lt;std::mutex&gt; lk1(e1.m, std::defer_lock);</span></span><br><span class="line">        <span class="comment">// std::unique_lock&lt;std::mutex&gt; lk2(e2.m, std::defer_lock);</span></span><br><span class="line">        <span class="comment">// std::lock(lk1, lk2);</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(io_mutex)</span></span>;</span><br><span class="line">            std::cout &lt;&lt; e1.id &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; e2.id &lt;&lt; <span class="string">&quot; got locks&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        e1.lunch_partners.<span class="built_in">push_back</span>(e2.id);</span><br><span class="line">        e2.lunch_partners.<span class="built_in">push_back</span>(e1.id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">send_mail</span>(e1, e2);</span><br><span class="line">    <span class="built_in">send_mail</span>(e2, e1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Employee <span class="title">alice</span><span class="params">(<span class="string">&quot;alice&quot;</span>)</span>, <span class="title">bob</span><span class="params">(<span class="string">&quot;bob&quot;</span>)</span>, <span class="title">christina</span><span class="params">(<span class="string">&quot;christina&quot;</span>)</span>, <span class="title">dave</span><span class="params">(<span class="string">&quot;dave&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在并行线程中指派，因为就午餐指派发邮件消耗很长时间</span></span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    threads.<span class="built_in">emplace_back</span>(assign_lunch_partner, std::<span class="built_in">ref</span>(alice), std::<span class="built_in">ref</span>(bob));</span><br><span class="line">    threads.<span class="built_in">emplace_back</span>(assign_lunch_partner, std::<span class="built_in">ref</span>(christina), std::<span class="built_in">ref</span>(bob));</span><br><span class="line">    threads.<span class="built_in">emplace_back</span>(assign_lunch_partner, std::<span class="built_in">ref</span>(christina), std::<span class="built_in">ref</span>(alice));</span><br><span class="line">    threads.<span class="built_in">emplace_back</span>(assign_lunch_partner, std::<span class="built_in">ref</span>(dave), std::<span class="built_in">ref</span>(bob));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;thread : threads)</span><br><span class="line">        thread.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; alice.<span class="built_in">output</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">              &lt;&lt; bob.<span class="built_in">output</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">              &lt;&lt; christina.<span class="built_in">output</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">              &lt;&lt; dave.<span class="built_in">output</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="使用更为灵活的std-unique-lock"><a href="#使用更为灵活的std-unique-lock" class="headerlink" title="使用更为灵活的std::unique_lock"></a>使用更为灵活的<code>std::unique_lock</code></h4><p><code>std::unqiue_lock</code> 使用更为自由的不变量，这样 <code>std::unique_lock</code> 实例不会总与互斥量的数据类型 相关，使用起来要比 <code>std:lock_guard</code> 更加灵活。首先，可将 <code>std::adopt_lock</code> 作为第二个参数传入 构造函数，对互斥量进行管理；也可以将 <code>std::defer_lock</code> 作为第二个参数传递进去，表明互斥量应 保持解锁状态。这样，就可以被 <code>std::unique_lock</code> 对象(不是互斥量)的 <code>lock()</code> 函数所获取，或传递 <code>std::unique_lock</code> 对象到 <code>std::lock()</code> 中。</p><p>当你想要锁定互斥锁时，可以创建类型为 <code>std::unique_lock</code>的局部变量，并将该互斥锁作为参数传递。 构造unique_lock时，它将锁定互斥锁，并且销毁该互斥锁后，它将解锁该互斥锁。 更重要的是：如果引发异常，则将调用 <code>std::unique_lock</code> 析构函数，因此互斥量将被解锁。</p><p><a href="https://stackoverflow.com/questions/14709233/how-to-use-create-unique-lock-in-c">示例 1 代码来源于Stack Overflow</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> some_shared_var = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">    &#123;  <span class="comment">// Critical section</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(my_mutex)</span></span>;</span><br><span class="line">        some_shared_var += a;</span><br><span class="line">    &#125;  <span class="comment">// End of critical section</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><a href="https://zh.cppreference.com/w/cpp/thread/unique_lock">示例 2 代码来源于std::unique_lock</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  示例 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Box</span><span class="params">(<span class="keyword">int</span> num)</span> : num_things&#123;</span>num&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num_things;</span><br><span class="line">    std::mutex m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Box &amp;from, Box &amp;to, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 仍未实际取锁</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(from.m, std::defer_lock)</span></span>;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(to.m, std::defer_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁两个 unique_lock 而不死锁</span></span><br><span class="line">    std::<span class="built_in">lock</span>(lock1, lock2);</span><br><span class="line"></span><br><span class="line">    from.num_things -= num;</span><br><span class="line">    to.num_things += num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#x27;from.m&#x27; 与 &#x27;to.m&#x27; 互斥解锁于 &#x27;unique_lock&#x27; 析构函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Box <span class="title">acc1</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">Box <span class="title">acc2</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(transfer, std::ref(acc1), std::ref(acc2), <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(transfer, std::ref(acc2), std::ref(acc1), <span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>我们现在会用C++写多线程代码啦，但是如何避免死锁，何种情况该用<code>std::lock_guard</code> 、<code>std::shared_timed_mutex</code>、<code>std::scoped_lock</code>、<code>std::unique_lock</code>，仍需要多加练习噢。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;C++11开始支持多线程编程，并在之后的版本中不断完善。&lt;/p&gt;
&lt;h4 id=&quot;Hello-World单线程写法：&quot;&gt;&lt;a href=&quot;#Hello-World单线程写法：&quot; class=&quot;headerlink&quot; title=&quot;Hello World单线程写法：&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="你发现了一条咸鱼" scheme="https://blog.winnerwinter.com/categories/%E4%BD%A0%E5%8F%91%E7%8E%B0%E4%BA%86%E4%B8%80%E6%9D%A1%E5%92%B8%E9%B1%BC/"/>
    
    
  </entry>
  
  <entry>
    <title>C++11 featureの右值引用</title>
    <link href="https://blog.winnerwinter.com/2019/11/06/c11-feature%E3%81%AE%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    <id>https://blog.winnerwinter.com/2019/11/06/c11-feature%E3%81%AE%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</id>
    <published>2019-11-06T04:46:46.000Z</published>
    <updated>2021-12-09T13:16:50.085Z</updated>
    
    <content type="html"><![CDATA[<p>C++11的feature应该不能算new feature了叭，毕竟这个版本已经年代久远了。来，我们学习一下C++11的右值引用。</p><h4 id="什么是左值，什么是右值？"><a href="#什么是左值，什么是右值？" class="headerlink" title="什么是左值，什么是右值？"></a>什么是左值，什么是右值？</h4><p>lvalue这个词来自于C语言，指的是可以放在赋值表达式左边的事物——在栈上或堆上分配的命名对象，或者其他对象成员——有明确的内存地址。</p><p>rvalue这个词也来源于C语言，指的是可以出现在赋值表达式右侧的对象——例如，文字常量和临时变量。</p><h4 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h4><p>首先我们回顾一下年代更为久远的左值引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> var=<span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; ref=var;  <span class="comment">// 创建一个var的引用</span></span><br><span class="line">ref=<span class="number">99</span>;</span><br><span class="line"><span class="built_in">assert</span>(var==<span class="number">99</span>);  <span class="comment">// 原型的值被改变了，因为引用被赋值了 </span></span><br></pre></td></tr></table></figure><p>左值引用只能被绑定在左值上，而不是右值。 因此左值引用不能这样子写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; i=<span class="number">42</span>;  <span class="comment">// 编译失败</span></span><br></pre></td></tr></table></figure><p>不过我们可以钻空子。像这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>&amp; i = <span class="number">42</span>;</span><br></pre></td></tr></table></figure><h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><p>C++11标准介绍了_右值引用_(rvalue reference)，这种方式只能绑定右值，不能绑定左值，其通过两个<code>&amp;&amp;</code>来进行声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; i=<span class="number">42</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>不能绑定左值噢：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j=<span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; k=j;  <span class="comment">// 编译失败  </span></span><br></pre></td></tr></table></figure><h4 id="右值引用用途の移动语义"><a href="#右值引用用途の移动语义" class="headerlink" title="右值引用用途の移动语义"></a>右值引用用途の移动语义</h4><blockquote><p>右值通常都是临时的，所以可以随意修改；如果知道函数的某个参数是一个右值，就可以将其看作为一个临时存储或“窃取”内容，也不影响程序的正确性。这就意味着，比起拷贝右值参数的内容，不如移动其内容。动态数组比较大的时候，这样能节省很多内存分配，提供更多的优化空间。</p></blockquote><p>精简版：在传参的时候使用右值引用可以避免在内存中创建重复的变量副本，空间复杂度更低。</p><p>举个例子叭，比如老的这种写法就很耗内存：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_copy</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt; <span class="keyword">const</span>&amp; vec_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(vec_)</span></span>;</span><br><span class="line">  vec.<span class="built_in">push_back</span>(<span class="number">42</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在以上代码中，一个函数以<code>std::vector&lt;int&gt;</code>作为一个参数，就需要将其<strong>拷贝</strong>进来，而不对原始的数据做任何操作。</p><p>如果使用右值引用版本的函数来重载这个函数，就能避免在传入右值的时候，函数会进行内部拷贝的过程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_copy</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt; &amp;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vec.<span class="built_in">push_back</span>(<span class="number">42</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="右值引用用途の-函数模板"><a href="#右值引用用途の-函数模板" class="headerlink" title="右值引用用途の 函数模板"></a>右值引用用途の 函数模板</h4><p>如果函数模板参数以右值引用作为一个模板参数，当对应位置提供左值的时候，模板会自动将其类型认定为左值引用；当提供右值的时候，会当做普通数据使用。</p><p>我帮你整理一下思路：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(函数模板参数以右值引用作为一个模板参数)&#123;</span><br><span class="line">    <span class="keyword">if</span>(对应位置提供左值)&#123;</span><br><span class="line">        模板会自动将其类型认定为左值引用</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(对应位置提供右值)&#123;</span><br><span class="line">        会当做普通数据使用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个栗子，定义一个函数模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125; </span><br></pre></td></tr></table></figure><p>随后传入一个右值，T的类型将被推导为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">foo</span>(<span class="number">42</span>);  <span class="comment">// foo&lt;int&gt;(42)</span></span><br><span class="line"><span class="built_in">foo</span>(<span class="number">3.14159</span>);  <span class="comment">// foo&lt;double&gt;&lt;3.14159&gt;</span></span><br><span class="line"><span class="built_in">foo</span>(std::<span class="built_in">string</span>());  <span class="comment">// foo&lt;std::string&gt;(std::string()) </span></span><br></pre></td></tr></table></figure><p>不过，向foo传入左值的时候，T会被推导为一个左值引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">foo</span>(i);  <span class="comment">// foo&lt;int&amp;&gt;(i) </span></span><br></pre></td></tr></table></figure><p>因为函数参数声明为<code>T&amp;&amp;</code>，所以就是引用的引用，可以视为是原始的引用类型。那么foo()就相当于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo&lt;<span class="keyword">int</span>&amp;&gt;(); <span class="comment">// void foo&lt;int&amp;&gt;(int&amp; t); </span></span><br></pre></td></tr></table></figure><p>这就允许一个函数模板既可以即接受左值，又可以接受右值参数。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>我萌先回顾了左值、右值的术语概念和左值引用的语法，然后介绍了右值引用的语法，最后讲了右值引用的两种用途：移动语义和函数模板。</p><p>加油啦，你最棒！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;C++11的feature应该不能算new feature了叭，毕竟这个版本已经年代久远了。来，我们学习一下C++11的右值引用。&lt;/p&gt;
&lt;h4 id=&quot;什么是左值，什么是右值？&quot;&gt;&lt;a href=&quot;#什么是左值，什么是右值？&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="你发现了一条咸鱼" scheme="https://blog.winnerwinter.com/categories/%E4%BD%A0%E5%8F%91%E7%8E%B0%E4%BA%86%E4%B8%80%E6%9D%A1%E5%92%B8%E9%B1%BC/"/>
    
    
  </entry>
  
  <entry>
    <title>ES6箭头函数の小陷阱</title>
    <link href="https://blog.winnerwinter.com/2019/11/05/es6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E3%81%AE%E5%B0%8F%E9%99%B7%E9%98%B1/"/>
    <id>https://blog.winnerwinter.com/2019/11/05/es6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E3%81%AE%E5%B0%8F%E9%99%B7%E9%98%B1/</id>
    <published>2019-11-05T13:07:43.000Z</published>
    <updated>2021-12-09T13:07:52.432Z</updated>
    
    <content type="html"><![CDATA[<p>ES6箭头函数语法糖真好吃，不过也有一些小陷阱噢~</p><p>噜啦啦噜啦啦噜啦噜啦咧~我萌一起来看看箭头函数の两种陷阱叭！！</p><h4 id="箭头函数和对象字面量"><a href="#箭头函数和对象字面量" class="headerlink" title="箭头函数和对象字面量"></a>箭头函数和对象字面量</h4><p>箭头函数提供了更简短的语法，可以将函数编写为具有隐式返回值的 lambda 表达式。比如使用一个函数映射一些数组。使用常规函数可能会多出很多空行。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> n * n;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>用 lambda 样式的箭头函数来写的话，就会写成两行优雅、易读的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">numbers.map(<span class="function"><span class="params">n</span> =&gt;</span> n * n);</span><br></pre></td></tr></table></figure><p>在这种用例中，箭头函数的表现符合预期，它将值本身相乘并返回到包含 [1, 4, 9, 16] 的新数组。</p><p>但<strong>如果你尝试映射到对象，那么结果可能和你想象的不一样</strong>了。例如，假设我们试图将数字映射到包含如下值的对象数组中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">numbers.map(<span class="function"><span class="params">n</span> =&gt;</span> &#123; <span class="attr">value</span>: n &#125;);</span><br></pre></td></tr></table></figure><p>这里的结果实际上是一个包含未定义值的数组。虽然看起来在这里返回一个对象，但是解释器看到的东西完全不一样。花括号被解释为箭头函数的块作用域，而值语句最后实际上成为了标签。<strong>在解释器眼里，它看起来是这样的</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">numbers.map(<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="attr">value</span>:</span><br><span class="line">    n</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>解决方法在这里。<strong>只需要将对象包装在括号中</strong>，就可以将它变成一个表达式而不是一个块语句，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">numbers.map(<span class="function"><span class="params">n</span> =&gt;</span> (&#123; <span class="attr">value</span>: n &#125;));</span><br></pre></td></tr></table></figure><p>这会计算出一个包含对象数组的数组，该对象数组具有预期的值。</p><h4 id="箭头函数和绑定"><a href="#箭头函数和绑定" class="headerlink" title="箭头函数和绑定"></a>箭头函数和绑定</h4><p>箭头函数没有自己的 this 绑定，即它们的 this 值和封闭词法作用域的 this 值是一样的。</p><p>箭头函数的this 绑定很可能与你原本所想的不一样。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> calculator = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">add</span>: <span class="function">(<span class="params">values</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = values.reduce(<span class="function">(<span class="params">a, v</span>) =&gt;</span> a + v, <span class="built_in">this</span>.value);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">calculator.add([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(calculator.value);  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>我们希望这里的 this 绑定为此处的 calculator 对象，但<strong>实际上 this 绑定最后要么是未定义，要么是全局对象，具体取决于代码是否在严格模式下运行</strong>。这是因为这里最接近的词汇作用域是全局作用域。在严格模式下这是未定义的。（否则，它会是浏览器的窗口对象（或 Node.js 兼容环境中的过程对象。</p><p>常规函数具有 this 绑定。在对象上调用时，this 将指向该对象，因此常规函数依然是获得成员函数的正确途径:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> calculator = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">values</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = values.reduce(<span class="function">(<span class="params">a, v</span>) =&gt;</span> a + v, <span class="built_in">this</span>.value);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">calculator.add([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); </span><br><span class="line"><span class="built_in">console</span>.log(calculator.value);  <span class="comment">// 6 </span></span><br></pre></td></tr></table></figure><p>另外，由于箭头函数没有 this 绑定，因此<strong>无法使用Function.prototype.call、Function.prototype.bind 和 Function.prototype.apply</strong>。声明箭头函数后，this 绑定设置为固定，无法更改。</p><p>因此，下面的示例将遇到与之前类似的问题：当调用 adder 的 add 函数时，<strong>this 绑定又成了全局对象</strong>，尽管我们尝试使用 Function.prototype.call 覆盖它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> adder = &#123;</span><br><span class="line">    <span class="attr">add</span>: <span class="function">(<span class="params">values</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = values.reduce(<span class="function">(<span class="params">a, v</span>) =&gt;</span> a + v, <span class="built_in">this</span>.value);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> calculator = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line">adder.add.call(calculator, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>什么时候IDE才能学会自己写代码 :)</p><p>参考链接：</p><p><a href="https://medium.com/better-programming/lesser-known-javascript-hazards-8d688a463b1f">Lesser-Known JavaScript Hazards</a></p><p><a href="https://www.ecma-international.org/ecma-262/9.0/index.html">ECMAScript® 2018 Language Specification</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ES6箭头函数语法糖真好吃，不过也有一些小陷阱噢~&lt;/p&gt;
&lt;p&gt;噜啦啦噜啦啦噜啦噜啦咧~我萌一起来看看箭头函数の两种陷阱叭！！&lt;/p&gt;
&lt;h4 id=&quot;箭头函数和对象字面量&quot;&gt;&lt;a href=&quot;#箭头函数和对象字面量&quot; class=&quot;headerlink&quot; title=&quot;</summary>
      
    
    
    
    <category term="你发现了一条咸鱼" scheme="https://blog.winnerwinter.com/categories/%E4%BD%A0%E5%8F%91%E7%8E%B0%E4%BA%86%E4%B8%80%E6%9D%A1%E5%92%B8%E9%B1%BC/"/>
    
    
  </entry>
  
  <entry>
    <title>己亥#12 | 乌拉~日漫好好看哦</title>
    <link href="https://blog.winnerwinter.com/2019/09/27/%E5%B7%B1%E4%BA%A512-%E4%B9%8C%E6%8B%89%E6%97%A5%E6%BC%AB%E5%A5%BD%E5%A5%BD%E7%9C%8B%E5%93%A6/"/>
    <id>https://blog.winnerwinter.com/2019/09/27/%E5%B7%B1%E4%BA%A512-%E4%B9%8C%E6%8B%89%E6%97%A5%E6%BC%AB%E5%A5%BD%E5%A5%BD%E7%9C%8B%E5%93%A6/</id>
    <published>2019-09-27T13:55:33.000Z</published>
    <updated>2021-12-09T12:31:31.985Z</updated>
    
    <content type="html"><![CDATA[<p>今天久违地打了篮球。已经记不清上次打球是什么时候了。最近希望去游泳。上次游泳的时间是2019年8月13日，距今已有一个多月。我对游泳的向往是其他体育活动无法替代的，因为游泳使我感到安逸。</p><p>本周看了《热诚传说 X》《热诚传说第二季》，旷了很多课但是并没有把时间用来学习，而是看了一部讲述清朝康熙宫廷的古装电视剧。目前在追《某科学的一方通行》。</p><p>看日漫的过程中，可以感受到，日漫表达的主题大都是追求世界和平、人们和谐相处。在日漫的正面派人物中，少有猜疑、谋略和权术。而中国封建古装剧有所不同，凡事讲求智取，成事前需要总体谋划，顾全大局。</p><p>在一战、二战之时，日本是一个军国主义的君主立宪制国家，当时日本民众皆臣民，应当服从假借天王之名的一切号召。那为何发展至今，日本的动漫却表达出对美好纯净的世界的向往和对战争的厌恶呢？</p><blockquote><p>自1889年起，日本是一个<a href="https://zh.wikipedia.org/wiki/%E5%90%9B%E4%B8%BB%E7%AB%8B%E5%AE%AA%E5%88%B6">君主立宪制</a>的国家，当时的宪法为《<a href="https://zh.wikipedia.org/wiki/%E5%A4%A7%E6%97%A5%E6%9C%AC%E5%B8%9D%E5%9C%8B%E6%86%B2%E6%B3%95">大日本帝国宪法</a>》，又称<a href="https://zh.wikipedia.org/wiki/%E6%98%8E%E6%B2%BB%E6%86%B2%E6%B3%95">明治宪法</a>。<a href="https://zh.wikipedia.org/wiki/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%B8%96%E7%95%8C%E5%A4%A7%E6%88%B0">第二次世界大战</a>后，新制定的<a href="https://zh.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC%E5%9B%BD%E5%AE%AA%E6%B3%95">日本国宪法</a>规定，<a href="https://zh.wikipedia.org/wiki/%E5%A4%A9%E7%9A%87">天皇</a>是国民团结的象征，对政府不具有干涉力。</p><p>根据<a href="https://zh.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC%E5%9C%8B%E6%86%B2%E6%B3%95%E7%AC%AC%E4%B9%9D%E6%A2%9D">日本国宪法第九条</a>，日本永远放弃战争的和平主义原则奉为神圣不可侵犯的权利，但同时为了灵活参与国际事务“威胁或使用武力作为解决国际争端的手段”写进宪法。</p><p><a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E7%9B%9F%E5%9C%8B%E8%BB%8D%E4%BA%8B%E4%BD%94%E9%A0%98%E6%97%A5%E6%9C%AC">同盟国军事占领</a>下现行宪法，1946年11月3日公布修改了<a href="https://zh.wikipedia.org/wiki/%E5%A4%A7%E6%97%A5%E6%9C%AC%E5%B8%9D%E5%9C%8B%E6%86%B2%E6%B3%95">大日本帝国宪法</a>，1947年5月3日施行以来，日本国内一直存在修改宪法的议论。不少保守派政治家主张，因为现行宪法是美国草拟的，没有正统性。但长期以来，日本社会大多不重视宪法修改问题。</p><p>来源：<a href="https://zh.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC%E6%94%BF%E6%B2%BB">维基百科-日本政治</a></p></blockquote><p>二战后，日本战败，同盟军驻日。期间日本修改过宪法。自新宪法颁布以来，人们的人权大大提高，日军在宪法中的地位大大降低。久而久之，日军江河日下。</p><p>那么改宪对各方有何好处呢？首先，通过制定法律来降低日军在本国的地位，日军对同盟国的威胁降低。其次，日本人得到了更大程度的自由，更多地考虑如何过好日子而不是如何上阵杀敌。最后，对日军没有好处只有坏处。</p><p>日漫描绘理想化的环境，体现了人们对和平世界美好生活的向往。但是现实非理想，一味保持单纯清净的心，难以应付多变的世界。世事变坏莫测，掌握谋略权术是必须的。正是出于生存的需要， 才有了前人对谋略的总结，才有了《鬼谷子》《战国策》《孙子兵法》等。谋事在人，世界的美好发展有赖于人们的共同努力；生而为人，当为造福全人类而读书。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天久违地打了篮球。已经记不清上次打球是什么时候了。最近希望去游泳。上次游泳的时间是2019年8月13日，距今已有一个多月。我对游泳的向往是其他体育活动无法替代的，因为游泳使我感到安逸。&lt;/p&gt;
&lt;p&gt;本周看了《热诚传说 X》《热诚传说第二季》，旷了很多课但是并没有把时间用</summary>
      
    
    
    
    <category term="日常" scheme="https://blog.winnerwinter.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>《Expelled from Paradise》观后感</title>
    <link href="https://blog.winnerwinter.com/2019/05/11/%E3%80%8Aexpelled-from-paradise%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F/"/>
    <id>https://blog.winnerwinter.com/2019/05/11/%E3%80%8Aexpelled-from-paradise%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F/</id>
    <published>2019-05-11T02:16:27.000Z</published>
    <updated>2021-12-09T12:31:31.980Z</updated>
    
    <content type="html"><![CDATA[<p>因为光年推荐，我看了<a href="https://www.bilibili.com/video/av15559036?from=search&seid=16722803249049422964">Expelled from Paradise</a>这部电影。</p><p>不得不说，艺术源于生活又高于生活。女主的容貌、身材实在是太好了叭——可以想象艺术家设计女主身材的时候有多猥琐用心。萌萌的，即便是她倔强的一面，也很可爱。</p><p>男主的人品有点坏，不过坏得恰到好处，他耍无赖的时候情节略带戏剧性。在女主有需要的时候，会适时提供帮助。</p><p>光年之所以推荐这部电影，是因为我们之前聊到人工智能与人类是否能共存这个话题，而这部电影的乐园里的人格、弗隆提亞·賽格 (フロンティアセッター)是典型的人工智能形象。</p><p>弗隆提亞·賽格 是自我更新到有“我”的意识的人工智能新生事物，致力于独自完成发射火箭送人类探索太空的任务。乐园里的人格（比如女主）是二进制数据，表面上无痛无痒幸福快乐。</p><p>剧情伊始，人工智能新时代，数据人格比肉体人类先进多了，真是实名羡慕。剧情以 [ 乐园服务器被入侵，女主去调查 ] 展开。不过越往后看，会发现主编另有话说。</p><p><strong>电影的主题应该是人生而自由。</strong></p><p>在乐园里，地位越高的人格会得到越多的计算资源。计算资源越多，人格的行动力越强，本领越大。女主对工作认真负责，多年的付出从来不负女主所望，她现已身至三等官。</p><p>人的欲望是无限的人民对美好生活的需要是日益增长的，二进制人格也难以幸免。为了获得更多的计算资源，女主努力工作，盼望有朝一日升到一等官。  </p><p>男主是一个凡夫俗子，对物质的看法比较现实。他多次帮助乐园（有酬）解决困难，并因为表现出色而多次收到乐园的邀请，请他加入乐园，成为二进制人格的一分子。</p><p>男主从来都不接受乐园的邀请。女主不解——乐园物质极大丰富日子可以过得很潇洒，为何男主不肯加入？</p><p>追求高质量生活的女主，并没有发现利益关系早已纠缠了她。举个例子：为了在同行中抢功劳，她趁早出发调查黑客身份。而打算抢功劳的人格又岂止女主一个？</p><p>男主的生活就比较随性了，在芜芜杂世中，他保留着对音乐的爱好，夜间开车累了就主张睡觉（这种表现是日出而作日落而息的一个缩影）。乐园里有阳光照射不到的地方，人际社会一样有。但是男主历尽千帆，仍是少年。</p><p>我并没有贬低奋斗者的意思。我建议一个人去追求自己内心想要的生活，而不要被束缚于追求社会风气所推崇的生活。而且，在追求自己内心想要的生活的过程中，难免会受到不必要的干扰，这时要认清自己内心的想法。</p><p>在影片最后，女主重新（之所以说是重新，是因为她曾是人类）回到人间生活。逃离乐园到人间生活，依然有可能被人间的利益关系所纠缠。不过当一个人已经被利益纠缠得狼狈不堪，那么请尽快用全力摆脱现状，重新开始生活，而女主也确实做到了这一点。</p><p>弗隆提亞·賽格的思想得到进一步解放，决定<strong>自行</strong>探索太空。</p><p>相关文章：<a href="https://blog.qfstudio.net/2018/09/%E8%87%AA%E7%94%B1%E6%98%AF%E4%BA%BA%E6%9C%80%E5%AE%9D%E8%B4%B5%E7%9A%84%E6%9D%83%E5%88%A9-%E7%94%B1%E7%94%B5%E5%BD%B1%E3%80%8A%E6%97%A0%E9%97%AE%E8%A5%BF%E4%B8%9C%E3%80%8B%E6%83%B3/#comment-119">自由是人最宝贵的权利——由电影《无问西东》想到的</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为光年推荐，我看了&lt;a href=&quot;https://www.bilibili.com/video/av15559036?from=search&amp;seid=16722803249049422964&quot;&gt;Expelled from Paradise&lt;/a&gt;这部电影。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="杂萃" scheme="https://blog.winnerwinter.com/categories/%E6%9D%82%E8%90%83/"/>
    
    
  </entry>
  
  <entry>
    <title>樱花雨の仰望</title>
    <link href="https://blog.winnerwinter.com/2019/05/01/%E5%8B%9D%E8%80%85%E3%81%AE%E5%86%AC%E3%81%AE%E4%BB%B0%E6%9C%9B/"/>
    <id>https://blog.winnerwinter.com/2019/05/01/%E5%8B%9D%E8%80%85%E3%81%AE%E5%86%AC%E3%81%AE%E4%BB%B0%E6%9C%9B/</id>
    <published>2019-04-30T16:24:09.000Z</published>
    <updated>2021-12-09T13:23:22.617Z</updated>
    
    <content type="html"><![CDATA[<p>樱花雨对某些大城市的生活条件、经济结构做了一些调查，于是对各大城市形成了以下印象。</p><p><strong>香港(Hong Kong)：</strong></p><p>香港人的经济收入主要依靠贸易、金融、工商业、旅游业。由于香港人比较浮躁，急于获得收入，在此地很难培育出高科技公司。与此同时，由于香港的融资政策支持同股不同权，非常适合科技公司的发展，所以内地的科技公司比较喜欢去香港上市。香港高校的教师都是全球聘请的，而且薪资很高。</p><p>因为香港经济结构缺少底层基础（比如农业、工业），所以我对当地长期的经济发展并不看好。但是，由于政策原因和历史原因，香港在短时间内将仍然是国际大都市。（香港的政策对融资和贸易很友好。）</p><p>如果你打算从事会计、金融、旅游、司法等类型的工作，或者你拥有博士学位，可以考虑来港就业。</p><p>IT从业人员就不要考虑来香港就业了，香港的软件大部分都外包出去了。IT人员在港的经济收入不比内地高，而同等收入的情况下内地生活条件高很多。</p><img src="/2019/05/01/%E5%8B%9D%E8%80%85%E3%81%AE%E5%86%AC%E3%81%AE%E4%BB%B0%E6%9C%9B/%E9%A6%99%E6%B8%AF%E4%BA%A7%E4%B8%9A%E7%BB%93%E6%9E%84.png" class="" title="香港产业结构"><p><strong>深圳：</strong></p><p>深圳城的平均年龄低，坐公交、坐地铁、在街上走，将会遇到很多小姐姐/小哥哥。深圳外地人比较多，来了就是深圳人，基本不可能受到当地人的排挤，每逢春节深圳就变成一座空城。深圳非常重视人才，在政策上有多项吸引人才的计划，比如<a href="http://www.gaoxinbutie.com/haiwairencai/">孔雀计划</a>。深圳的产业政策对科技公司比较友好，<a href="https://hr.tencent.com/">腾讯</a>总部、<a href="https://talent.baidu.com/external/baidu/index.html">百度</a>总部、<a href="https://hr.xunlei.com/">迅雷</a>总部、华大基因都在此落户，也不乏正在成长的中小企业。香港的大部分软件外包都扔给了深圳。据了解，2018年深圳的GDP超过了香港。</p><p>我个人认为，在中国，深圳是对IT从业人员最友好的城市。</p><p><strong>广州：</strong></p><p><a href="https://hr.tencent.com/">腾讯</a>广研部、<a href="http://www.super.cn/joinus.php">超级课程表</a>、<a href="https://job.vip.com/">唯品会</a>、<a href="https://hr.163.com/">网易</a>在广州。广州的物价不比广东的其他城市贵，只是房价贵。本地人喜欢讲粤语，不过普通话也相当常用。外国人来中国采购货物，比较喜欢来广州，因为广州的商品种类比较全面，可以一次性买到合适的货物。广交会在对外贸易方面有巨大影响力。</p><p>广州也是一个对IT从业人员比较友好的城市，是就业的好地方。</p><img src="/2019/05/01/%E5%8B%9D%E8%80%85%E3%81%AE%E5%86%AC%E3%81%AE%E4%BB%B0%E6%9C%9B/%E7%B2%A4%E6%B8%AF%E6%BE%B3%E5%A4%A7%E6%B9%BE%E5%8C%BA%E5%A4%A7%E5%9F%8E%E5%B8%82.png" class="" title="粤港澳大湾区四大中心城市"><p><strong>东莞：</strong></p><p><a href="http://career.huawei.com/reccampportal/campus4_index.html#campus4/content.html">华为</a>多部门从深圳搬来这里，将会带动一系列的发展。在东莞，相关的利益集团可能会因为华为的到来而业务量大增。东莞与深圳交界，企业之间有一定的交流。</p><p><strong>珠海：</strong></p><p>博主曾去过珠海两次，珠海的风土人情挺好的，环境优美，居住体验会很好。珠海的IT氛围不及广深，不过也有一些IT企业在此，比如<a href="http://job.kingsoft.com/">金山</a>、<a href="https://www.now.cn/aboutus/join.php">时代互联</a>、<a href="http://hr.meizu.com/">魅族</a>、<a href="http://www.ixoyo.com/">云游科技</a>（李兰云）、<a href="http://www.ixinyou.com/recruit/index.html">心游科技</a>（创新工场、金山投资），此城的IT水平比全国也高很多。珠海的经济水平可以，房价略低于广深，是个居住的好地方。</p><p><strong>东京(とうきょう)：</strong></p><p>日本比较繁华的地方。满街快步的行人，表达着它快节奏的生活理念。比起日本其他地方，这里的景色并不是那么突出，（如果忽略高昂的物价的话）这里绝对是一个玩乐和购物必去的地方。 东京的住宅水平较好，高级的有格调的建筑比较多。需要程序员的企业一抓一大把， 这里还有<a href="https://careers.google.com/locations/tokyo/">谷歌日本</a>、<a href="https://careers.microsoft.com/us/en/l-tokyo">微软日本</a>、<a href="https://www.facebook.com/careers/locations/tokyo/?locations%5B0%5D=Tokyo,%20Japan">Facebook日本</a>、<a href="https://www.amazon.jobs/en/locations/tokyo-area-japan">亚马逊日本</a>、<a href="https://www-07.ibm.com/employment/jp/">IBM日本</a>。</p><img src="/2019/05/01/%E5%8B%9D%E8%80%85%E3%81%AE%E5%86%AC%E3%81%AE%E4%BB%B0%E6%9C%9B/image-1.png" class="" title="东京、大阪系对外贸易大城市です（2017）"><p><strong>大阪(おおさか)：</strong></p><p>位于东京横滨500公里之外，日本的传统的、现代的文化都可以感受。 作为中国人来说的话，东京是个过于讲究的城市，大家坐电车也不说话，走路时也和规矩，走路速度也快，整体氛围没有那么放松。但是大阪这个城市就很接地气儿！大家穿的衣服也比东京鲜艳，性格开朗，不是说在公共场合大吵大闹OK，但是高高兴兴的一边走一边说笑，电车上和朋友稍微出声说说话还是不会招白眼的。</p><img src="/2019/05/01/%E5%8B%9D%E8%80%85%E3%81%AE%E5%86%AC%E3%81%AE%E4%BB%B0%E6%9C%9B/image.png" class="" title="大阪の多元经济结构（2015）"><p><strong>横滨(よこはま)：</strong></p><p>GDP居日本第三。和东京几乎同处同一个地区，很多人会在横滨居住东京上班。这里的物价比东京便宜啊。</p><p><strong>名古屋(なごや)：</strong></p><p>位于东京和大阪的正中偏大阪的位置，是中部地区的最大城市，也是中部都市圈的中心。</p><p><strong>旧金山(San Francisco)及其毗邻区域：</strong></p><p>硅谷啊，硅谷啊<del>神仙居住和工作的地方，科技巨头数量应该是世界第一的了。微软、谷歌、Oracle、Intel、Yahoo、Twitter、Facebook、LinkedIn、EBay 、Mozilla、 Symantec Corporation、Netflix 、Wikipedia维基媒体基金会，巴拉巴拉</del>巴拉巴拉小魔仙~</p><p><strong>西雅图(Seattle)：</strong></p><p>在旧金山以北1300公里，IT阵形和（硅谷）湾区有一拼。</p><p><strong>多伦多(Toronto)：</strong></p><p>略略略。</p><p>重要的不是你在哪儿</p><p>而是你在那里做什么</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;樱花雨对某些大城市的生活条件、经济结构做了一些调查，于是对各大城市形成了以下印象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;香港(Hong Kong)：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;香港人的经济收入主要依靠贸易、金融、工商业、旅游业。由于香港人比较浮躁，急于获得收入，在此地很难培</summary>
      
    
    
    
    <category term="杂萃" scheme="https://blog.winnerwinter.com/categories/%E6%9D%82%E8%90%83/"/>
    
    
  </entry>
  
</feed>
