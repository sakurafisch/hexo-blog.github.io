<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="樱花雨"><title>樱花雨</title><meta name="description" content="爱你来自于蛮荒，一生不借谁的光"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">首页</a></li><li> <a href="/about">关于</a></li><li> <a href="/links">友链</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)" style="display:none;"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="/images/logo.webp"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:200px;" alt="favicon"><h3 title=""><a href="/">樱花雨</a></h3><div class="description"><p>爱你来自于蛮荒，一生不借谁的光</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/sakurafisch"><i class="fa fa-github"></i></a></li><li><a href="mailto:sakurafisch@gmail.com"><i class="fa fa-envelope"></i></a></li><li><a href="https://blog.winnerwinter.com/atom.xml"><i class="fa fa-rss"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> 樱花雨</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/03/12/%E5%BA%9A%E5%AD%904-%E8%BF%8E%E6%9D%A5%E8%AF%BE%E5%A4%9A%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9/">庚子#4 | 迎来课多的第一天</a></h3></div><div class="post-content"><div class="card"><p><p>闹钟打破清静的早晨，慵懒的少年从被窝中坐起，缓缓下床，开始了他繁忙的一天。</p>
<p>今天的第一件事情莫过于抢阿里云半年免费的云服务器。用云服务器做完作业就扔是一个再好不过的选择。然鹅我因操作的时候犹豫了一下选哪个Linux发行版而错失良机。明日手速快起来，Arch Linux预定！</p>
<p>今天总共上了组网、Linux、Linux实验和法语课。上完Linux实验的时候不想继续上课差点把法语课给退了。不过考虑到还有七天的退课时间，还是先上上课再考虑。不过本次法语课体验不错，所以我得上完下周的课再考虑退不退，大概率不退吧。</p>
<p>法语比俄语明显简单好多，跟日语相比的话我比较不出来。</p>
<p>前天做完了2017英语一的卷子还没来得及整理相关笔记，今天又获得了新的课程作业。布置作业是不对的，委屈。</p>
<p>今天的吃饭时间受到了课程影响，不过久违地吃到了排骨和瘦肉，粗略算了一下价格感觉亏大了，近期不宜猪肉宜鸡鸭。</p>
<p>每周只有星期四课多其实还好啦。明天写作业，刻海星~</p>
<p>《Tu me manques》Sheryfa Luna</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-03-12</span><span class="leancloud_visitors"></span><span>About 386 words, 1 min 17 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2020/03/09/%E5%BA%9A%E5%AD%903-%E5%AF%92%E5%81%87%E7%BB%88%E4%BA%86/">庚子#3 | 寒假终了</a></h3></div><div class="post-content"><div class="card"><p><p>按常理来说，今天是开学的第一天，但我星期三才有课。所以今天姑且也算是我的寒假。</p>
<p>这个寒假原本打算会独居很久的。为了应对新冠疫情，我在除夕前夕和家人团聚，并且至今也没有独居。 过年期间打了几天麻将。</p>
<p>翡翠台的《黄金有罪》《大酱园》《独孤皇后》成为了茶余饭后的消遣。其中《独孤皇后》 现在还没大结局 。在初一的时候看了《重啟咲良田》，《超炮T》一直有跟进，白井黑子牛逼！很喜欢up主机智的党妹的说话风格。</p>
<p>疫情期间虽然有新电影免费放在了网上，但是我没有去看，倒是花钱重温了《速度与激情8》。一直很喜欢速度与激情这个系列的电影，并非纯粹因为其中的街头情节和人物放荡不羁的个性，更因为他们无论遭遇何种困难始终把家庭放在很很重要的位置。</p>
<p>把学习强国刷到了4700分，最近开始着手经典诵读。</p>
<p>因为个人原因，我退出了一个十多人的里面全是放假就会聚到一起玩的初中同学的微信群。因为我希望今年的社交活动少一点。为了降低自己发说说和发朋友圈的欲望，把QQ空间设成了私密，把朋友圈设成了三天可见。里面没什么隐私，仅仅为了降低自己发说说和发朋友圈的欲望而已。</p>
<p>kx的社恐比我想象中的严重。</p>
<p>和wuli成了研友，互相打卡日常工作。</p>
<p>最近每天下午四点都会条件反射地觅食,主要是鸡蛋炒饭，衣带渐紧终不悔。</p>
<p>不爱听音乐的程序员不是好吃货。</p>
<p>《苏丽珂》The Red Army Choir</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-03-09</span><span class="leancloud_visitors"></span><span>About 538 words, 1 min 47 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2019/11/17/%E5%B7%B1%E4%BA%A513-%E5%90%91%E6%81%B6%E5%8A%BF%E5%8A%9B%E4%BD%8E%E5%A4%B4/">己亥#13 | 向恶势力低头</a></h3></div><div class="post-content"><div class="card"><p><p>开学的时候本以为自己有充足的时间考一下证，于是当时一冲动就报了BEC-H。记得国庆回家的时候，我带了BEC-H的书和数据结构的书回家，本来打算在家主要看BEC的，但结果BEC实在太难了，在家一直看数据结构。</p>
<p>这个学期要修的学分还是比较多，能自由安排的时间有限。之前曾探索过光年的时间安排方式，即以日历安排行程，不过现在已经弃坑了。本人还是比较喜欢随性的生活。</p>
<p>2019.11.16，这一天早上我去中大东校区考了BEC-H的阅读、写作、听力。阅读做了前面两大题就想离场放弃了。不过看到旁边的人都在认真做，我才坚持了下来。就感觉写作好写一点。听力听着听着手就微微颤抖。向恶势力低头。</p>
<p>早上考完听读写的我已经是没有灵魂的我了。回我校睡了一觉。按照准考证的时间，晚上18：45~19：00是口语考试时间。我在睡觉期间辗转反侧悲愤难眠，最终决定放弃口语部分的考试。</p>
<p>晚上没有去考试，取而代之的是，我去了GOGO和kx喝奶茶聊天。主要是聊天。从中我了解到广外的外语氛围真的比我校好很多。她舍友今天也考BEC，这位在我看来很神奇的她的舍友此前已经考过托福/雅思了的。</p>
<p>广外真是一个神奇的地方。在这个地方，外语大佬真多。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-11-17</span><span class="leancloud_visitors"></span><span>About 458 words, 1 min 31 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2019/11/06/%E5%88%9D%E6%8E%A2c%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%94%81%E6%9C%BA%E5%88%B6/">初探C++多线程和锁机制</a></h3></div><div class="post-content"><div class="card"><p><p>C++11开始支持多线程编程，并在之后的版本中不断完善。</p>
<h4 id="Hello-World单线程写法："><a href="#Hello-World单线程写法：" class="headerlink" title="Hello World单线程写法："></a>Hello World单线程写法：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello World\n&quot;</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="Hello-World多线程写法："><a href="#Hello-World多线程写法：" class="headerlink" title="Hello World多线程写法："></a>Hello World多线程写法：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span> <span class="comment">// 1</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span>      <span class="comment">// 2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello Concurrent World\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(hello)</span></span>; <span class="comment">// 3</span></span><br><span class="line">    t.<span class="built_in">join</span>();             <span class="comment">// 4</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="量产线程的写法："><a href="#量产线程的写法：" class="headerlink" title="量产线程的写法："></a>量产线程的写法：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_work</span><span class="params">(<span class="keyword">unsigned</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        threads.<span class="built_in">emplace_back</span>(do_work, i); <span class="comment">// 产生线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;entry : threads) <span class="comment">// 对每个线程调用 join()</span></span><br><span class="line">        entry.<span class="built_in">join</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="使用-std-lock-guard-保护共享数据："><a href="#使用-std-lock-guard-保护共享数据：" class="headerlink" title="使用 std::lock_guard 保护共享数据："></a>使用 <code>std::lock_guard</code> 保护共享数据：</h4><p>C++中通过实例化<code>std::mutex</code>创建互斥量实例，通过成员函数 <code>lock()</code> 对互斥量上锁，<code>unlock()</code> 进行解锁。不过，实践中不推荐直接去调用成员函数，调用成员函数就意味着，必须在每个函数出口都要去调用 <code>unlock()</code>，也包括异常的情况。C++标准库为互斥量提供了一个RAII语法的模板类<code>std::lock_guard</code>，在构造时就能提供已锁的互斥量，并在析构的时候进行解锁，从而保证了一个已锁互斥量能被正确解锁。</p>
<p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/thread/lock_guard">代码来源于 std::lock_guard</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g_i = <span class="number">0</span>;</span><br><span class="line">std::mutex g_i_mutex; <span class="comment">// 保护 g_i</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">safe_increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_i_mutex)</span></span>;</span><br><span class="line">    ++g_i;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// g_i_mutex 在锁离开作用域时自动释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(safe_increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(safe_increment)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="使用-std-shared-timed-mutex-避免数据竞争"><a href="#使用-std-shared-timed-mutex-避免数据竞争" class="headerlink" title="使用 std::shared_timed_mutex 避免数据竞争"></a>使用 <code>std::shared_timed_mutex</code> 避免数据竞争</h4><p><code>shared_timed_mutex</code> 类是能用于保护数据免受多个线程同时访问的同步原语。与其他促进排他性访问的互斥类型相反，拥有二个层次的访问：</p>
<ul>
<li>  <em>共享</em> - 多个线程能共享同一互斥的所有权。</li>
<li>  <em>排他性</em> - 仅一个线程能占有互斥。</li>
</ul>
<p>共享互斥通常用于多个读线程能同时访问同一资源而不导致数据竞争，但只有一个写线程能访问的情形。</p>
<p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/thread/shared_timed_mutex">代码来源于std::shared_timed_mutex</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">R</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">mutable</span> std::shared_timed_mutex mut;</span><br><span class="line">    <span class="comment">/* 数据 */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    R &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> R &amp;other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 要求排他性所有权以写入 *this</span></span><br><span class="line">        std::unique_lock&lt;std::shared_timed_mutex&gt; <span class="built_in">lhs</span>(mut, std::defer_lock);</span><br><span class="line">        <span class="comment">// 要求共享所有权以读取 other</span></span><br><span class="line">        <span class="function">std::shared_lock&lt;std::shared_timed_mutex&gt; <span class="title">rhs</span><span class="params">(other.mut, std::defer_lock)</span></span>;</span><br><span class="line">        std::<span class="built_in">lock</span>(lhs, rhs);</span><br><span class="line">        <span class="comment">/* 赋值数据 */</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    R r;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="使用-std-scoped-lock-避免死锁"><a href="#使用-std-scoped-lock-避免死锁" class="headerlink" title="使用 std::scoped_lock 避免死锁"></a>使用 <code>std::scoped_lock</code> 避免死锁</h4><p>线程有对锁的竞争：一对线程需要对他们所有的互斥量做一些操作，其中每个线程都有一个互斥量，且等待另一个解锁。这样没有线程能工作，因为他们都在等待对方释放互斥量。这种情况就是死锁，它的最大问题就是由两个或两个以上的互斥量来锁定一个操作。</p>
<p>C++标准库有办法解决这个问题，<code>std::scoped_lock</code>——可以一次性锁住多个(两个以上)的互斥量，并且没有副作用(死锁风险)，而且是RAII风格喵~。</p>
<p>以下示例用 <code>std::scoped_lock</code> 锁定互斥对而不死锁，且为 RAII 风格。</p>
<p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/thread/scoped_lock">代码来源于std::scoped_lock</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">Employee</span>(std::string id) : <span class="built_in">id</span>(id) &#123;&#125;</span><br><span class="line">    std::string id;</span><br><span class="line">    std::vector&lt;std::string&gt; lunch_partners;</span><br><span class="line">    std::mutex m;</span><br><span class="line">    <span class="function">std::string <span class="title">output</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::string ret = <span class="string">&quot;Employee &quot;</span> + id + <span class="string">&quot; has lunch partners: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;partner : lunch_partners)</span><br><span class="line">            ret += partner + <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_mail</span><span class="params">(Employee &amp;, Employee &amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 模拟耗时的发信操作</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign_lunch_partner</span><span class="params">(Employee &amp;e1, Employee &amp;e2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> std::mutex io_mutex;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(io_mutex)</span></span>;</span><br><span class="line">        std::cout &lt;&lt; e1.id &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; e2.id &lt;&lt; <span class="string">&quot; are waiting for locks&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用 std::scoped_lock 取得二个锁，而无需担心</span></span><br><span class="line">        <span class="comment">// 其他对 assign_lunch_partner 的调用死锁我们</span></span><br><span class="line">        <span class="comment">// 而且它亦提供便利的 RAII 风格机制</span></span><br><span class="line"></span><br><span class="line">        <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(e1.m, e2.m)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等价代码 1 （用 std::lock 和 std::lock_guard ）</span></span><br><span class="line">        <span class="comment">// std::lock(e1.m, e2.m);</span></span><br><span class="line">        <span class="comment">// std::lock_guard&lt;std::mutex&gt; lk1(e1.m, std::adopt_lock);</span></span><br><span class="line">        <span class="comment">// std::lock_guard&lt;std::mutex&gt; lk2(e2.m, std::adopt_lock);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等价代码 2 （若需要 unique_lock ，例如对于条件变量）</span></span><br><span class="line">        <span class="comment">// std::unique_lock&lt;std::mutex&gt; lk1(e1.m, std::defer_lock);</span></span><br><span class="line">        <span class="comment">// std::unique_lock&lt;std::mutex&gt; lk2(e2.m, std::defer_lock);</span></span><br><span class="line">        <span class="comment">// std::lock(lk1, lk2);</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(io_mutex)</span></span>;</span><br><span class="line">            std::cout &lt;&lt; e1.id &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; e2.id &lt;&lt; <span class="string">&quot; got locks&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        e1.lunch_partners.<span class="built_in">push_back</span>(e2.id);</span><br><span class="line">        e2.lunch_partners.<span class="built_in">push_back</span>(e1.id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">send_mail</span>(e1, e2);</span><br><span class="line">    <span class="built_in">send_mail</span>(e2, e1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Employee <span class="title">alice</span><span class="params">(<span class="string">&quot;alice&quot;</span>)</span>, <span class="title">bob</span><span class="params">(<span class="string">&quot;bob&quot;</span>)</span>, <span class="title">christina</span><span class="params">(<span class="string">&quot;christina&quot;</span>)</span>, <span class="title">dave</span><span class="params">(<span class="string">&quot;dave&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在并行线程中指派，因为就午餐指派发邮件消耗很长时间</span></span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    threads.<span class="built_in">emplace_back</span>(assign_lunch_partner, std::<span class="built_in">ref</span>(alice), std::<span class="built_in">ref</span>(bob));</span><br><span class="line">    threads.<span class="built_in">emplace_back</span>(assign_lunch_partner, std::<span class="built_in">ref</span>(christina), std::<span class="built_in">ref</span>(bob));</span><br><span class="line">    threads.<span class="built_in">emplace_back</span>(assign_lunch_partner, std::<span class="built_in">ref</span>(christina), std::<span class="built_in">ref</span>(alice));</span><br><span class="line">    threads.<span class="built_in">emplace_back</span>(assign_lunch_partner, std::<span class="built_in">ref</span>(dave), std::<span class="built_in">ref</span>(bob));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;thread : threads)</span><br><span class="line">        thread.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; alice.<span class="built_in">output</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">              &lt;&lt; bob.<span class="built_in">output</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">              &lt;&lt; christina.<span class="built_in">output</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">              &lt;&lt; dave.<span class="built_in">output</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="使用更为灵活的std-unique-lock"><a href="#使用更为灵活的std-unique-lock" class="headerlink" title="使用更为灵活的std::unique_lock"></a>使用更为灵活的<code>std::unique_lock</code></h4><p><code>std::unqiue_lock</code> 使用更为自由的不变量，这样 <code>std::unique_lock</code> 实例不会总与互斥量的数据类型 相关，使用起来要比 <code>std:lock_guard</code> 更加灵活。首先，可将 <code>std::adopt_lock</code> 作为第二个参数传入 构造函数，对互斥量进行管理；也可以将 <code>std::defer_lock</code> 作为第二个参数传递进去，表明互斥量应 保持解锁状态。这样，就可以被 <code>std::unique_lock</code> 对象(不是互斥量)的 <code>lock()</code> 函数所获取，或传递 <code>std::unique_lock</code> 对象到 <code>std::lock()</code> 中。</p>
<p>当你想要锁定互斥锁时，可以创建类型为 <code>std::unique_lock</code>的局部变量，并将该互斥锁作为参数传递。 构造unique_lock时，它将锁定互斥锁，并且销毁该互斥锁后，它将解锁该互斥锁。 更重要的是：如果引发异常，则将调用 <code>std::unique_lock</code> 析构函数，因此互斥量将被解锁。</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/14709233/how-to-use-create-unique-lock-in-c">示例 1 代码来源于Stack Overflow</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> some_shared_var = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">    &#123;  <span class="comment">// Critical section</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(my_mutex)</span></span>;</span><br><span class="line">        some_shared_var += a;</span><br><span class="line">    &#125;  <span class="comment">// End of critical section</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/thread/unique_lock">示例 2 代码来源于std::unique_lock</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  示例 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Box</span><span class="params">(<span class="keyword">int</span> num)</span> : num_things&#123;</span>num&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num_things;</span><br><span class="line">    std::mutex m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Box &amp;from, Box &amp;to, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 仍未实际取锁</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(from.m, std::defer_lock)</span></span>;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(to.m, std::defer_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁两个 unique_lock 而不死锁</span></span><br><span class="line">    std::<span class="built_in">lock</span>(lock1, lock2);</span><br><span class="line"></span><br><span class="line">    from.num_things -= num;</span><br><span class="line">    to.num_things += num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#x27;from.m&#x27; 与 &#x27;to.m&#x27; 互斥解锁于 &#x27;unique_lock&#x27; 析构函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Box <span class="title">acc1</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">Box <span class="title">acc2</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(transfer, std::ref(acc1), std::ref(acc2), <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(transfer, std::ref(acc2), std::ref(acc1), <span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>我们现在会用C++写多线程代码啦，但是如何避免死锁，何种情况该用<code>std::lock_guard</code> 、<code>std::shared_timed_mutex</code>、<code>std::scoped_lock</code>、<code>std::unique_lock</code>，仍需要多加练习噢。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-11-06</span><span class="leancloud_visitors"></span><span>About 1945 words, 6 min 29 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2019/11/06/c11-feature%E3%81%AE%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/">C++11 featureの右值引用</a></h3></div><div class="post-content"><div class="card"><p><p>C++11的feature应该不能算new feature了叭，毕竟这个版本已经年代久远了。来，我们学习一下C++11的右值引用。</p>
<h4 id="什么是左值，什么是右值？"><a href="#什么是左值，什么是右值？" class="headerlink" title="什么是左值，什么是右值？"></a>什么是左值，什么是右值？</h4><p>lvalue这个词来自于C语言，指的是可以放在赋值表达式左边的事物——在栈上或堆上分配的命名对象，或者其他对象成员——有明确的内存地址。</p>
<p>rvalue这个词也来源于C语言，指的是可以出现在赋值表达式右侧的对象——例如，文字常量和临时变量。</p>
<h4 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h4><p>首先我们回顾一下年代更为久远的左值引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> var=<span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; ref=var;  <span class="comment">// 创建一个var的引用</span></span><br><span class="line">ref=<span class="number">99</span>;</span><br><span class="line"><span class="built_in">assert</span>(var==<span class="number">99</span>);  <span class="comment">// 原型的值被改变了，因为引用被赋值了 </span></span><br></pre></td></tr></table></figure>

<p>左值引用只能被绑定在左值上，而不是右值。 因此左值引用不能这样子写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; i=<span class="number">42</span>;  <span class="comment">// 编译失败</span></span><br></pre></td></tr></table></figure>

<p>不过我们可以钻空子。像这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>&amp; i = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><p>C++11标准介绍了_右值引用_(rvalue reference)，这种方式只能绑定右值，不能绑定左值，其通过两个<code>&amp;&amp;</code>来进行声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; i=<span class="number">42</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>不能绑定左值噢：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j=<span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; k=j;  <span class="comment">// 编译失败  </span></span><br></pre></td></tr></table></figure>

<h4 id="右值引用用途の移动语义"><a href="#右值引用用途の移动语义" class="headerlink" title="右值引用用途の移动语义"></a>右值引用用途の移动语义</h4><blockquote>
<p>右值通常都是临时的，所以可以随意修改；如果知道函数的某个参数是一个右值，就可以将其看作为一个临时存储或“窃取”内容，也不影响程序的正确性。这就意味着，比起拷贝右值参数的内容，不如移动其内容。动态数组比较大的时候，这样能节省很多内存分配，提供更多的优化空间。</p>
</blockquote>
<p>精简版：在传参的时候使用右值引用可以避免在内存中创建重复的变量副本，空间复杂度更低。</p>
<p>举个例子叭，比如老的这种写法就很耗内存：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_copy</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt; <span class="keyword">const</span>&amp; vec_)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(vec_)</span></span>;</span><br><span class="line">  vec.<span class="built_in">push_back</span>(<span class="number">42</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在以上代码中，一个函数以<code>std::vector&lt;int&gt;</code>作为一个参数，就需要将其<strong>拷贝</strong>进来，而不对原始的数据做任何操作。</p>
<p>如果使用右值引用版本的函数来重载这个函数，就能避免在传入右值的时候，函数会进行内部拷贝的过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_copy</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt; &amp;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vec.<span class="built_in">push_back</span>(<span class="number">42</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="右值引用用途の-函数模板"><a href="#右值引用用途の-函数模板" class="headerlink" title="右值引用用途の 函数模板"></a>右值引用用途の 函数模板</h4><p>如果函数模板参数以右值引用作为一个模板参数，当对应位置提供左值的时候，模板会自动将其类型认定为左值引用；当提供右值的时候，会当做普通数据使用。</p>
<p>我帮你整理一下思路：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(函数模板参数以右值引用作为一个模板参数)&#123;</span><br><span class="line">    <span class="keyword">if</span>(对应位置提供左值)&#123;</span><br><span class="line">        模板会自动将其类型认定为左值引用</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(对应位置提供右值)&#123;</span><br><span class="line">        会当做普通数据使用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个栗子，定义一个函数模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125; </span><br></pre></td></tr></table></figure>

<p>随后传入一个右值，T的类型将被推导为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">foo</span>(<span class="number">42</span>);  <span class="comment">// foo&lt;int&gt;(42)</span></span><br><span class="line"><span class="built_in">foo</span>(<span class="number">3.14159</span>);  <span class="comment">// foo&lt;double&gt;&lt;3.14159&gt;</span></span><br><span class="line"><span class="built_in">foo</span>(std::<span class="built_in">string</span>());  <span class="comment">// foo&lt;std::string&gt;(std::string()) </span></span><br></pre></td></tr></table></figure>

<p>不过，向foo传入左值的时候，T会被推导为一个左值引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">foo</span>(i);  <span class="comment">// foo&lt;int&amp;&gt;(i) </span></span><br></pre></td></tr></table></figure>

<p>因为函数参数声明为<code>T&amp;&amp;</code>，所以就是引用的引用，可以视为是原始的引用类型。那么foo()就相当于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo&lt;<span class="keyword">int</span>&amp;&gt;(); <span class="comment">// void foo&lt;int&amp;&gt;(int&amp; t); </span></span><br></pre></td></tr></table></figure>

<p>这就允许一个函数模板既可以即接受左值，又可以接受右值参数。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>我萌先回顾了左值、右值的术语概念和左值引用的语法，然后介绍了右值引用的语法，最后讲了右值引用的两种用途：移动语义和函数模板。</p>
<p>加油啦，你最棒！</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-11-06</span><span class="leancloud_visitors"></span><span>About 1098 words, 3 min 39 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2019/11/05/es6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E3%81%AE%E5%B0%8F%E9%99%B7%E9%98%B1/">ES6箭头函数の小陷阱</a></h3></div><div class="post-content"><div class="card"><p><p>ES6箭头函数语法糖真好吃，不过也有一些小陷阱噢~</p>
<p>噜啦啦噜啦啦噜啦噜啦咧~我萌一起来看看箭头函数の两种陷阱叭！！</p>
<h4 id="箭头函数和对象字面量"><a href="#箭头函数和对象字面量" class="headerlink" title="箭头函数和对象字面量"></a>箭头函数和对象字面量</h4><p>箭头函数提供了更简短的语法，可以将函数编写为具有隐式返回值的 lambda 表达式。比如使用一个函数映射一些数组。使用常规函数可能会多出很多空行。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> n * n;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>用 lambda 样式的箭头函数来写的话，就会写成两行优雅、易读的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">numbers.map(<span class="function"><span class="params">n</span> =&gt;</span> n * n);</span><br></pre></td></tr></table></figure>

<p>在这种用例中，箭头函数的表现符合预期，它将值本身相乘并返回到包含 [1, 4, 9, 16] 的新数组。</p>
<p>但<strong>如果你尝试映射到对象，那么结果可能和你想象的不一样</strong>了。例如，假设我们试图将数字映射到包含如下值的对象数组中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">numbers.map(<span class="function"><span class="params">n</span> =&gt;</span> &#123; <span class="attr">value</span>: n &#125;);</span><br></pre></td></tr></table></figure>

<p>这里的结果实际上是一个包含未定义值的数组。虽然看起来在这里返回一个对象，但是解释器看到的东西完全不一样。花括号被解释为箭头函数的块作用域，而值语句最后实际上成为了标签。<strong>在解释器眼里，它看起来是这样的</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">numbers.map(<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="attr">value</span>:</span><br><span class="line">    n</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>解决方法在这里。<strong>只需要将对象包装在括号中</strong>，就可以将它变成一个表达式而不是一个块语句，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">numbers.map(<span class="function"><span class="params">n</span> =&gt;</span> (&#123; <span class="attr">value</span>: n &#125;));</span><br></pre></td></tr></table></figure>

<p>这会计算出一个包含对象数组的数组，该对象数组具有预期的值。</p>
<h4 id="箭头函数和绑定"><a href="#箭头函数和绑定" class="headerlink" title="箭头函数和绑定"></a>箭头函数和绑定</h4><p>箭头函数没有自己的 this 绑定，即它们的 this 值和封闭词法作用域的 this 值是一样的。</p>
<p>箭头函数的this 绑定很可能与你原本所想的不一样。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> calculator = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">add</span>: <span class="function">(<span class="params">values</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = values.reduce(<span class="function">(<span class="params">a, v</span>) =&gt;</span> a + v, <span class="built_in">this</span>.value);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">calculator.add([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(calculator.value);  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>我们希望这里的 this 绑定为此处的 calculator 对象，但<strong>实际上 this 绑定最后要么是未定义，要么是全局对象，具体取决于代码是否在严格模式下运行</strong>。这是因为这里最接近的词汇作用域是全局作用域。在严格模式下这是未定义的。（否则，它会是浏览器的窗口对象（或 Node.js 兼容环境中的过程对象。</p>
<p>常规函数具有 this 绑定。在对象上调用时，this 将指向该对象，因此常规函数依然是获得成员函数的正确途径:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> calculator = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">values</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = values.reduce(<span class="function">(<span class="params">a, v</span>) =&gt;</span> a + v, <span class="built_in">this</span>.value);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">calculator.add([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); </span><br><span class="line"><span class="built_in">console</span>.log(calculator.value);  <span class="comment">// 6 </span></span><br></pre></td></tr></table></figure>

<p>另外，由于箭头函数没有 this 绑定，因此<strong>无法使用Function.prototype.call、Function.prototype.bind 和 Function.prototype.apply</strong>。声明箭头函数后，this 绑定设置为固定，无法更改。</p>
<p>因此，下面的示例将遇到与之前类似的问题：当调用 adder 的 add 函数时，<strong>this 绑定又成了全局对象</strong>，尽管我们尝试使用 Function.prototype.call 覆盖它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> adder = &#123;</span><br><span class="line">    <span class="attr">add</span>: <span class="function">(<span class="params">values</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = values.reduce(<span class="function">(<span class="params">a, v</span>) =&gt;</span> a + v, <span class="built_in">this</span>.value);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> calculator = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line">adder.add.call(calculator, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>什么时候IDE才能学会自己写代码 :)</p>
<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://medium.com/better-programming/lesser-known-javascript-hazards-8d688a463b1f">Lesser-Known JavaScript Hazards</a></p>
<p><a target="_blank" rel="noopener" href="https://www.ecma-international.org/ecma-262/9.0/index.html">ECMAScript® 2018 Language Specification</a></p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-11-05</span><span class="leancloud_visitors"></span><span>About 914 words, 3 min 2 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2019/09/27/%E5%B7%B1%E4%BA%A512-%E4%B9%8C%E6%8B%89%E6%97%A5%E6%BC%AB%E5%A5%BD%E5%A5%BD%E7%9C%8B%E5%93%A6/">己亥#12 | 乌拉~日漫好好看哦</a></h3></div><div class="post-content"><div class="card"><p><p>今天久违地打了篮球。已经记不清上次打球是什么时候了。最近希望去游泳。上次游泳的时间是2019年8月13日，距今已有一个多月。我对游泳的向往是其他体育活动无法替代的，因为游泳使我感到安逸。</p>
<p>本周看了《热诚传说 X》《热诚传说第二季》，旷了很多课但是并没有把时间用来学习，而是看了一部讲述清朝康熙宫廷的古装电视剧。目前在追《某科学的一方通行》。</p>
<p>看日漫的过程中，可以感受到，日漫表达的主题大都是追求世界和平、人们和谐相处。在日漫的正面派人物中，少有猜疑、谋略和权术。而中国封建古装剧有所不同，凡事讲求智取，成事前需要总体谋划，顾全大局。</p>
<p>在一战、二战之时，日本是一个军国主义的君主立宪制国家，当时日本民众皆臣民，应当服从假借天王之名的一切号召。那为何发展至今，日本的动漫却表达出对美好纯净的世界的向往和对战争的厌恶呢？</p>
<blockquote>
<p>自1889年起，日本是一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%90%9B%E4%B8%BB%E7%AB%8B%E5%AE%AA%E5%88%B6">君主立宪制</a>的国家，当时的宪法为《<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A4%A7%E6%97%A5%E6%9C%AC%E5%B8%9D%E5%9C%8B%E6%86%B2%E6%B3%95">大日本帝国宪法</a>》，又称<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%98%8E%E6%B2%BB%E6%86%B2%E6%B3%95">明治宪法</a>。<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%B8%96%E7%95%8C%E5%A4%A7%E6%88%B0">第二次世界大战</a>后，新制定的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC%E5%9B%BD%E5%AE%AA%E6%B3%95">日本国宪法</a>规定，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A4%A9%E7%9A%87">天皇</a>是国民团结的象征，对政府不具有干涉力。</p>
<p>根据<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC%E5%9C%8B%E6%86%B2%E6%B3%95%E7%AC%AC%E4%B9%9D%E6%A2%9D">日本国宪法第九条</a>，日本永远放弃战争的和平主义原则奉为神圣不可侵犯的权利，但同时为了灵活参与国际事务“威胁或使用武力作为解决国际争端的手段”写进宪法。</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%90%8C%E7%9B%9F%E5%9C%8B%E8%BB%8D%E4%BA%8B%E4%BD%94%E9%A0%98%E6%97%A5%E6%9C%AC">同盟国军事占领</a>下现行宪法，1946年11月3日公布修改了<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A4%A7%E6%97%A5%E6%9C%AC%E5%B8%9D%E5%9C%8B%E6%86%B2%E6%B3%95">大日本帝国宪法</a>，1947年5月3日施行以来，日本国内一直存在修改宪法的议论。不少保守派政治家主张，因为现行宪法是美国草拟的，没有正统性。但长期以来，日本社会大多不重视宪法修改问题。</p>
<p>来源：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%97%A5%E6%9C%AC%E6%94%BF%E6%B2%BB">维基百科-日本政治</a></p>
</blockquote>
<p>二战后，日本战败，同盟军驻日。期间日本修改过宪法。自新宪法颁布以来，人们的人权大大提高，日军在宪法中的地位大大降低。久而久之，日军江河日下。</p>
<p>那么改宪对各方有何好处呢？首先，通过制定法律来降低日军在本国的地位，日军对同盟国的威胁降低。其次，日本人得到了更大程度的自由，更多地考虑如何过好日子而不是如何上阵杀敌。最后，对日军没有好处只有坏处。</p>
<p>日漫描绘理想化的环境，体现了人们对和平世界美好生活的向往。但是现实非理想，一味保持单纯清净的心，难以应付多变的世界。世事变坏莫测，掌握谋略权术是必须的。正是出于生存的需要， 才有了前人对谋略的总结，才有了《鬼谷子》《战国策》《孙子兵法》等。谋事在人，世界的美好发展有赖于人们的共同努力；生而为人，当为造福全人类而读书。</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-09-27</span><span class="leancloud_visitors"></span><span>About 948 words, 3 min 9 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2019/05/11/%E3%80%8Aexpelled-from-paradise%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F/">《Expelled from Paradise》观后感</a></h3></div><div class="post-content"><div class="card"><p><p>因为光年推荐，我看了<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av15559036?from=search&seid=16722803249049422964">Expelled from Paradise</a>这部电影。</p>
<p>不得不说，艺术源于生活又高于生活。女主的容貌、身材实在是太好了叭——可以想象艺术家设计女主身材的时候有多猥琐用心。萌萌的，即便是她倔强的一面，也很可爱。</p>
<p>男主的人品有点坏，不过坏得恰到好处，他耍无赖的时候情节略带戏剧性。在女主有需要的时候，会适时提供帮助。</p>
<p>光年之所以推荐这部电影，是因为我们之前聊到人工智能与人类是否能共存这个话题，而这部电影的乐园里的人格、弗隆提亞·賽格 (フロンティアセッター)是典型的人工智能形象。</p>
<p>弗隆提亞·賽格 是自我更新到有“我”的意识的人工智能新生事物，致力于独自完成发射火箭送人类探索太空的任务。乐园里的人格（比如女主）是二进制数据，表面上无痛无痒幸福快乐。</p>
<p>剧情伊始，人工智能新时代，数据人格比肉体人类先进多了，真是实名羡慕。剧情以 [ 乐园服务器被入侵，女主去调查 ] 展开。不过越往后看，会发现主编另有话说。</p>
<p><strong>电影的主题应该是人生而自由。</strong></p>
<p>在乐园里，地位越高的人格会得到越多的计算资源。计算资源越多，人格的行动力越强，本领越大。女主对工作认真负责，多年的付出从来不负女主所望，她现已身至三等官。</p>
<p>人的欲望是无限的人民对美好生活的需要是日益增长的，二进制人格也难以幸免。为了获得更多的计算资源，女主努力工作，盼望有朝一日升到一等官。  </p>
<p>男主是一个凡夫俗子，对物质的看法比较现实。他多次帮助乐园（有酬）解决困难，并因为表现出色而多次收到乐园的邀请，请他加入乐园，成为二进制人格的一分子。</p>
<p>男主从来都不接受乐园的邀请。女主不解——乐园物质极大丰富日子可以过得很潇洒，为何男主不肯加入？</p>
<p>追求高质量生活的女主，并没有发现利益关系早已纠缠了她。举个例子：为了在同行中抢功劳，她趁早出发调查黑客身份。而打算抢功劳的人格又岂止女主一个？</p>
<p>男主的生活就比较随性了，在芜芜杂世中，他保留着对音乐的爱好，夜间开车累了就主张睡觉（这种表现是日出而作日落而息的一个缩影）。乐园里有阳光照射不到的地方，人际社会一样有。但是男主历尽千帆，仍是少年。</p>
<p>我并没有贬低奋斗者的意思。我建议一个人去追求自己内心想要的生活，而不要被束缚于追求社会风气所推崇的生活。而且，在追求自己内心想要的生活的过程中，难免会受到不必要的干扰，这时要认清自己内心的想法。</p>
<p>在影片最后，女主重新（之所以说是重新，是因为她曾是人类）回到人间生活。逃离乐园到人间生活，依然有可能被人间的利益关系所纠缠。不过当一个人已经被利益纠缠得狼狈不堪，那么请尽快用全力摆脱现状，重新开始生活，而女主也确实做到了这一点。</p>
<p>弗隆提亞·賽格的思想得到进一步解放，决定<strong>自行</strong>探索太空。</p>
<p>相关文章：<a target="_blank" rel="noopener" href="https://blog.qfstudio.net/2018/09/%E8%87%AA%E7%94%B1%E6%98%AF%E4%BA%BA%E6%9C%80%E5%AE%9D%E8%B4%B5%E7%9A%84%E6%9D%83%E5%88%A9-%E7%94%B1%E7%94%B5%E5%BD%B1%E3%80%8A%E6%97%A0%E9%97%AE%E8%A5%BF%E4%B8%9C%E3%80%8B%E6%83%B3/#comment-119">自由是人最宝贵的权利——由电影《无问西东》想到的</a></p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-05-11</span><span class="leancloud_visitors"></span><span>About 1090 words, 3 min 38 sec  read</span></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2019/05/01/%E6%A8%B1%E8%8A%B1%E9%9B%A8%E3%81%AE%E4%BB%B0%E6%9C%9B/">樱花雨の仰望</a></h3></div><div class="post-content"><div class="card"><p><p>樱花雨对某些大城市的生活条件、经济结构做了一些调查，于是对各大城市形成了以下印象。</p>
<p><strong>香港(Hong Kong)：</strong></p>
<p>香港人的经济收入主要依靠贸易、金融、工商业、旅游业。由于香港人比较浮躁，急于获得收入，在此地很难培育出高科技公司。与此同时，由于香港的融资政策支持同股不同权，非常适合科技公司的发展，所以内地的科技公司比较喜欢去香港上市。香港高校的教师都是全球聘请的，而且薪资很高。</p>
<p>因为香港经济结构缺少底层基础（比如农业、工业），所以我对当地长期的经济发展并不看好。但是，由于政策原因和历史原因，香港在短时间内将仍然是国际大都市。（香港的政策对融资和贸易很友好。）</p>
<p>如果你打算从事会计、金融、旅游、司法等类型的工作，或者你拥有博士学位，可以考虑来港就业。</p>
<p>IT从业人员就不要考虑来香港就业了，香港的软件大部分都外包出去了。IT人员在港的经济收入不比内地高，而同等收入的情况下内地生活条件高很多。</p>
<img src="/2019/05/01/%E6%A8%B1%E8%8A%B1%E9%9B%A8%E3%81%AE%E4%BB%B0%E6%9C%9B/%E9%A6%99%E6%B8%AF%E4%BA%A7%E4%B8%9A%E7%BB%93%E6%9E%84.png" class="" title="香港产业结构">

<p><strong>深圳：</strong></p>
<p>深圳城的平均年龄低，坐公交、坐地铁、在街上走，将会遇到很多小姐姐/小哥哥。深圳外地人比较多，来了就是深圳人，基本不可能受到当地人的排挤，每逢春节深圳就变成一座空城。深圳非常重视人才，在政策上有多项吸引人才的计划，比如<a target="_blank" rel="noopener" href="http://www.gaoxinbutie.com/haiwairencai/">孔雀计划</a>。深圳的产业政策对科技公司比较友好，<a target="_blank" rel="noopener" href="https://hr.tencent.com/">腾讯</a>总部、<a target="_blank" rel="noopener" href="https://talent.baidu.com/external/baidu/index.html">百度</a>总部、<a target="_blank" rel="noopener" href="https://hr.xunlei.com/">迅雷</a>总部、华大基因都在此落户，也不乏正在成长的中小企业。香港的大部分软件外包都扔给了深圳。据了解，2018年深圳的GDP超过了香港。</p>
<p>我个人认为，在中国，深圳是对IT从业人员最友好的城市。</p>
<p><strong>广州：</strong></p>
<p><a target="_blank" rel="noopener" href="https://hr.tencent.com/">腾讯</a>广研部、<a target="_blank" rel="noopener" href="http://www.super.cn/joinus.php">超级课程表</a>、<a target="_blank" rel="noopener" href="https://job.vip.com/">唯品会</a>、<a target="_blank" rel="noopener" href="https://hr.163.com/">网易</a>在广州。广州的物价不比广东的其他城市贵，只是房价贵。本地人喜欢讲粤语，不过普通话也相当常用。外国人来中国采购货物，比较喜欢来广州，因为广州的商品种类比较全面，可以一次性买到合适的货物。广交会在对外贸易方面有巨大影响力。</p>
<p>广州也是一个对IT从业人员比较友好的城市，是就业的好地方。</p>
<img src="/2019/05/01/%E6%A8%B1%E8%8A%B1%E9%9B%A8%E3%81%AE%E4%BB%B0%E6%9C%9B/%E7%B2%A4%E6%B8%AF%E6%BE%B3%E5%A4%A7%E6%B9%BE%E5%8C%BA%E5%A4%A7%E5%9F%8E%E5%B8%82.png" class="" title="粤港澳大湾区四大中心城市">

<p><strong>东莞：</strong></p>
<p><a target="_blank" rel="noopener" href="http://career.huawei.com/reccampportal/campus4_index.html#campus4/content.html">华为</a>多部门从深圳搬来这里，将会带动一系列的发展。在东莞，相关的利益集团可能会因为华为的到来而业务量大增。东莞与深圳交界，企业之间有一定的交流。</p>
<p><strong>珠海：</strong></p>
<p>博主曾去过珠海两次，珠海的风土人情挺好的，环境优美，居住体验会很好。珠海的IT氛围不及广深，不过也有一些IT企业在此，比如<a target="_blank" rel="noopener" href="http://job.kingsoft.com/">金山</a>、<a target="_blank" rel="noopener" href="https://www.now.cn/aboutus/join.php">时代互联</a>、<a target="_blank" rel="noopener" href="http://hr.meizu.com/">魅族</a>、<a target="_blank" rel="noopener" href="http://www.ixoyo.com/">云游科技</a>（李兰云）、<a target="_blank" rel="noopener" href="http://www.ixinyou.com/recruit/index.html">心游科技</a>（创新工场、金山投资），此城的IT水平比全国也高很多。珠海的经济水平可以，房价略低于广深，是个居住的好地方。</p>
<p><strong>东京(とうきょう)：</strong></p>
<p>日本比较繁华的地方。满街快步的行人，表达着它快节奏的生活理念。比起日本其他地方，这里的景色并不是那么突出，（如果忽略高昂的物价的话）这里绝对是一个玩乐和购物必去的地方。 东京的住宅水平较好，高级的有格调的建筑比较多。需要程序员的企业一抓一大把， 这里还有<a target="_blank" rel="noopener" href="https://careers.google.com/locations/tokyo/">谷歌日本</a>、<a target="_blank" rel="noopener" href="https://careers.microsoft.com/us/en/l-tokyo">微软日本</a>、<a target="_blank" rel="noopener" href="https://www.facebook.com/careers/locations/tokyo/?locations%5B0%5D=Tokyo,%20Japan">Facebook日本</a>、<a target="_blank" rel="noopener" href="https://www.amazon.jobs/en/locations/tokyo-area-japan">亚马逊日本</a>、<a target="_blank" rel="noopener" href="https://www-07.ibm.com/employment/jp/">IBM日本</a>。</p>
<img src="/2019/05/01/%E6%A8%B1%E8%8A%B1%E9%9B%A8%E3%81%AE%E4%BB%B0%E6%9C%9B/image-1.png" class="" title="东京、大阪系对外贸易大城市です（2017）">

<p><strong>大阪(おおさか)：</strong></p>
<p>位于东京横滨500公里之外，日本的传统的、现代的文化都可以感受。 作为中国人来说的话，东京是个过于讲究的城市，大家坐电车也不说话，走路时也和规矩，走路速度也快，整体氛围没有那么放松。但是大阪这个城市就很接地气儿！大家穿的衣服也比东京鲜艳，性格开朗，不是说在公共场合大吵大闹OK，但是高高兴兴的一边走一边说笑，电车上和朋友稍微出声说说话还是不会招白眼的。</p>
<img src="/2019/05/01/%E6%A8%B1%E8%8A%B1%E9%9B%A8%E3%81%AE%E4%BB%B0%E6%9C%9B/image.png" class="" title="大阪の多元经济结构（2015）">

<p><strong>横滨(よこはま)：</strong></p>
<p>GDP居日本第三。和东京几乎同处同一个地区，很多人会在横滨居住东京上班。这里的物价比东京便宜啊。</p>
<p><strong>名古屋(なごや)：</strong></p>
<p>位于东京和大阪的正中偏大阪的位置，是中部地区的最大城市，也是中部都市圈的中心。</p>
<p><strong>旧金山(San Francisco)及其毗邻区域：</strong></p>
<p>作为宇宙中心的硅谷，科技巨头数量世界第一。微软、谷歌、Oracle、Intel、Yahoo、Twitter、Facebook、LinkedIn、EBay 、Mozilla、 Symantec Corporation、Netflix 、Wikipedia维基媒体基金会，巴拉巴拉<del>小魔仙</del></p>
<p><strong>西雅图(Seattle)：</strong></p>
<p>在旧金山以北1300公里，IT阵形和（硅谷）湾区有一拼。</p>
<p><strong>多伦多(Toronto)：</strong></p>
<p>略略略。</p>
<p>重要的不是你在哪儿</p>
<p>而是你在那里做什么</p>
</p></div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-05-01</span><span class="leancloud_visitors"></span><span>About 1545 words, 5 min 9 sec  read</span></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/">Previous</a></li></ul></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"Posts",PAGES:"Pages",CATEGORIES:"Categories",TAGS:"Tags",UNTITLED:"(Untitled)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Search..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>